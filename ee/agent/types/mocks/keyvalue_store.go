// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	mock "github.com/stretchr/testify/mock"
)

// NewGetter creates a new instance of Getter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGetter(t interface {
	mock.TestingT
	Cleanup(func())
}) *Getter {
	mock := &Getter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Getter is an autogenerated mock type for the Getter type
type Getter struct {
	mock.Mock
}

type Getter_Expecter struct {
	mock *mock.Mock
}

func (_m *Getter) EXPECT() *Getter_Expecter {
	return &Getter_Expecter{mock: &_m.Mock}
}

// Get provides a mock function for the type Getter
func (_mock *Getter) Get(key []byte) ([]byte, error) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) ([]byte, error)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Getter_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Getter_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key []byte
func (_e *Getter_Expecter) Get(key interface{}) *Getter_Get_Call {
	return &Getter_Get_Call{Call: _e.mock.On("Get", key)}
}

func (_c *Getter_Get_Call) Run(run func(key []byte)) *Getter_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Getter_Get_Call) Return(value []byte, err error) *Getter_Get_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *Getter_Get_Call) RunAndReturn(run func(key []byte) ([]byte, error)) *Getter_Get_Call {
	_c.Call.Return(run)
	return _c
}

// NewSetter creates a new instance of Setter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSetter(t interface {
	mock.TestingT
	Cleanup(func())
}) *Setter {
	mock := &Setter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Setter is an autogenerated mock type for the Setter type
type Setter struct {
	mock.Mock
}

type Setter_Expecter struct {
	mock *mock.Mock
}

func (_m *Setter) EXPECT() *Setter_Expecter {
	return &Setter_Expecter{mock: &_m.Mock}
}

// Set provides a mock function for the type Setter
func (_mock *Setter) Set(key []byte, value []byte) error {
	ret := _mock.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for Set")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) error); ok {
		r0 = returnFunc(key, value)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Setter_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type Setter_Set_Call struct {
	*mock.Call
}

// Set is a helper method to define mock.On call
//   - key []byte
//   - value []byte
func (_e *Setter_Expecter) Set(key interface{}, value interface{}) *Setter_Set_Call {
	return &Setter_Set_Call{Call: _e.mock.On("Set", key, value)}
}

func (_c *Setter_Set_Call) Run(run func(key []byte, value []byte)) *Setter_Set_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Setter_Set_Call) Return(err error) *Setter_Set_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Setter_Set_Call) RunAndReturn(run func(key []byte, value []byte) error) *Setter_Set_Call {
	_c.Call.Return(run)
	return _c
}

// NewDeleter creates a new instance of Deleter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDeleter(t interface {
	mock.TestingT
	Cleanup(func())
}) *Deleter {
	mock := &Deleter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Deleter is an autogenerated mock type for the Deleter type
type Deleter struct {
	mock.Mock
}

type Deleter_Expecter struct {
	mock *mock.Mock
}

func (_m *Deleter) EXPECT() *Deleter_Expecter {
	return &Deleter_Expecter{mock: &_m.Mock}
}

// Delete provides a mock function for the type Deleter
func (_mock *Deleter) Delete(keys ...[]byte) error {
	// []byte
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(...[]byte) error); ok {
		r0 = returnFunc(keys...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Deleter_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type Deleter_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - keys ...[]byte
func (_e *Deleter_Expecter) Delete(keys ...interface{}) *Deleter_Delete_Call {
	return &Deleter_Delete_Call{Call: _e.mock.On("Delete",
		append([]interface{}{}, keys...)...)}
}

func (_c *Deleter_Delete_Call) Run(run func(keys ...[]byte)) *Deleter_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 [][]byte
		variadicArgs := make([][]byte, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.([]byte)
			}
		}
		arg0 = variadicArgs
		run(
			arg0...,
		)
	})
	return _c
}

func (_c *Deleter_Delete_Call) Return(err error) *Deleter_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Deleter_Delete_Call) RunAndReturn(run func(keys ...[]byte) error) *Deleter_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAll provides a mock function for the type Deleter
func (_mock *Deleter) DeleteAll() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for DeleteAll")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Deleter_DeleteAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAll'
type Deleter_DeleteAll_Call struct {
	*mock.Call
}

// DeleteAll is a helper method to define mock.On call
func (_e *Deleter_Expecter) DeleteAll() *Deleter_DeleteAll_Call {
	return &Deleter_DeleteAll_Call{Call: _e.mock.On("DeleteAll")}
}

func (_c *Deleter_DeleteAll_Call) Run(run func()) *Deleter_DeleteAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Deleter_DeleteAll_Call) Return(err error) *Deleter_DeleteAll_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Deleter_DeleteAll_Call) RunAndReturn(run func() error) *Deleter_DeleteAll_Call {
	_c.Call.Return(run)
	return _c
}

// NewIterator creates a new instance of Iterator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIterator(t interface {
	mock.TestingT
	Cleanup(func())
}) *Iterator {
	mock := &Iterator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Iterator is an autogenerated mock type for the Iterator type
type Iterator struct {
	mock.Mock
}

type Iterator_Expecter struct {
	mock *mock.Mock
}

func (_m *Iterator) EXPECT() *Iterator_Expecter {
	return &Iterator_Expecter{mock: &_m.Mock}
}

// ForEach provides a mock function for the type Iterator
func (_mock *Iterator) ForEach(fn func(k []byte, v []byte) error) error {
	ret := _mock.Called(fn)

	if len(ret) == 0 {
		panic("no return value specified for ForEach")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(func(k []byte, v []byte) error) error); ok {
		r0 = returnFunc(fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Iterator_ForEach_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForEach'
type Iterator_ForEach_Call struct {
	*mock.Call
}

// ForEach is a helper method to define mock.On call
//   - fn func(k []byte, v []byte) error
func (_e *Iterator_Expecter) ForEach(fn interface{}) *Iterator_ForEach_Call {
	return &Iterator_ForEach_Call{Call: _e.mock.On("ForEach", fn)}
}

func (_c *Iterator_ForEach_Call) Run(run func(fn func(k []byte, v []byte) error)) *Iterator_ForEach_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func(k []byte, v []byte) error
		if args[0] != nil {
			arg0 = args[0].(func(k []byte, v []byte) error)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Iterator_ForEach_Call) Return(err error) *Iterator_ForEach_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Iterator_ForEach_Call) RunAndReturn(run func(fn func(k []byte, v []byte) error) error) *Iterator_ForEach_Call {
	_c.Call.Return(run)
	return _c
}

// NewUpdater creates a new instance of Updater. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUpdater(t interface {
	mock.TestingT
	Cleanup(func())
}) *Updater {
	mock := &Updater{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Updater is an autogenerated mock type for the Updater type
type Updater struct {
	mock.Mock
}

type Updater_Expecter struct {
	mock *mock.Mock
}

func (_m *Updater) EXPECT() *Updater_Expecter {
	return &Updater_Expecter{mock: &_m.Mock}
}

// Update provides a mock function for the type Updater
func (_mock *Updater) Update(kvPairs map[string]string) ([]string, error) {
	ret := _mock.Called(kvPairs)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(map[string]string) ([]string, error)); ok {
		return returnFunc(kvPairs)
	}
	if returnFunc, ok := ret.Get(0).(func(map[string]string) []string); ok {
		r0 = returnFunc(kvPairs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(map[string]string) error); ok {
		r1 = returnFunc(kvPairs)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Updater_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type Updater_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - kvPairs map[string]string
func (_e *Updater_Expecter) Update(kvPairs interface{}) *Updater_Update_Call {
	return &Updater_Update_Call{Call: _e.mock.On("Update", kvPairs)}
}

func (_c *Updater_Update_Call) Run(run func(kvPairs map[string]string)) *Updater_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 map[string]string
		if args[0] != nil {
			arg0 = args[0].(map[string]string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Updater_Update_Call) Return(strings []string, err error) *Updater_Update_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *Updater_Update_Call) RunAndReturn(run func(kvPairs map[string]string) ([]string, error)) *Updater_Update_Call {
	_c.Call.Return(run)
	return _c
}

// NewCounter creates a new instance of Counter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCounter(t interface {
	mock.TestingT
	Cleanup(func())
}) *Counter {
	mock := &Counter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Counter is an autogenerated mock type for the Counter type
type Counter struct {
	mock.Mock
}

type Counter_Expecter struct {
	mock *mock.Mock
}

func (_m *Counter) EXPECT() *Counter_Expecter {
	return &Counter_Expecter{mock: &_m.Mock}
}

// Count provides a mock function for the type Counter
func (_mock *Counter) Count() (int, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (int, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Counter_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type Counter_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
func (_e *Counter_Expecter) Count() *Counter_Count_Call {
	return &Counter_Count_Call{Call: _e.mock.On("Count")}
}

func (_c *Counter_Count_Call) Run(run func()) *Counter_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Counter_Count_Call) Return(n int, err error) *Counter_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *Counter_Count_Call) RunAndReturn(run func() (int, error)) *Counter_Count_Call {
	_c.Call.Return(run)
	return _c
}

// NewAppender creates a new instance of Appender. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAppender(t interface {
	mock.TestingT
	Cleanup(func())
}) *Appender {
	mock := &Appender{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Appender is an autogenerated mock type for the Appender type
type Appender struct {
	mock.Mock
}

type Appender_Expecter struct {
	mock *mock.Mock
}

func (_m *Appender) EXPECT() *Appender_Expecter {
	return &Appender_Expecter{mock: &_m.Mock}
}

// AppendValues provides a mock function for the type Appender
func (_mock *Appender) AppendValues(values ...[]byte) error {
	// []byte
	_va := make([]interface{}, len(values))
	for _i := range values {
		_va[_i] = values[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AppendValues")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(...[]byte) error); ok {
		r0 = returnFunc(values...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Appender_AppendValues_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AppendValues'
type Appender_AppendValues_Call struct {
	*mock.Call
}

// AppendValues is a helper method to define mock.On call
//   - values ...[]byte
func (_e *Appender_Expecter) AppendValues(values ...interface{}) *Appender_AppendValues_Call {
	return &Appender_AppendValues_Call{Call: _e.mock.On("AppendValues",
		append([]interface{}{}, values...)...)}
}

func (_c *Appender_AppendValues_Call) Run(run func(values ...[]byte)) *Appender_AppendValues_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 [][]byte
		variadicArgs := make([][]byte, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.([]byte)
			}
		}
		arg0 = variadicArgs
		run(
			arg0...,
		)
	})
	return _c
}

func (_c *Appender_AppendValues_Call) Return(err error) *Appender_AppendValues_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Appender_AppendValues_Call) RunAndReturn(run func(values ...[]byte) error) *Appender_AppendValues_Call {
	_c.Call.Return(run)
	return _c
}

// NewGetterSetter creates a new instance of GetterSetter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGetterSetter(t interface {
	mock.TestingT
	Cleanup(func())
}) *GetterSetter {
	mock := &GetterSetter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// GetterSetter is an autogenerated mock type for the GetterSetter type
type GetterSetter struct {
	mock.Mock
}

type GetterSetter_Expecter struct {
	mock *mock.Mock
}

func (_m *GetterSetter) EXPECT() *GetterSetter_Expecter {
	return &GetterSetter_Expecter{mock: &_m.Mock}
}

// Get provides a mock function for the type GetterSetter
func (_mock *GetterSetter) Get(key []byte) ([]byte, error) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) ([]byte, error)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// GetterSetter_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type GetterSetter_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key []byte
func (_e *GetterSetter_Expecter) Get(key interface{}) *GetterSetter_Get_Call {
	return &GetterSetter_Get_Call{Call: _e.mock.On("Get", key)}
}

func (_c *GetterSetter_Get_Call) Run(run func(key []byte)) *GetterSetter_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GetterSetter_Get_Call) Return(value []byte, err error) *GetterSetter_Get_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *GetterSetter_Get_Call) RunAndReturn(run func(key []byte) ([]byte, error)) *GetterSetter_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Set provides a mock function for the type GetterSetter
func (_mock *GetterSetter) Set(key []byte, value []byte) error {
	ret := _mock.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for Set")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) error); ok {
		r0 = returnFunc(key, value)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// GetterSetter_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type GetterSetter_Set_Call struct {
	*mock.Call
}

// Set is a helper method to define mock.On call
//   - key []byte
//   - value []byte
func (_e *GetterSetter_Expecter) Set(key interface{}, value interface{}) *GetterSetter_Set_Call {
	return &GetterSetter_Set_Call{Call: _e.mock.On("Set", key, value)}
}

func (_c *GetterSetter_Set_Call) Run(run func(key []byte, value []byte)) *GetterSetter_Set_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *GetterSetter_Set_Call) Return(err error) *GetterSetter_Set_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *GetterSetter_Set_Call) RunAndReturn(run func(key []byte, value []byte) error) *GetterSetter_Set_Call {
	_c.Call.Return(run)
	return _c
}

// NewCloser creates a new instance of Closer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCloser(t interface {
	mock.TestingT
	Cleanup(func())
}) *Closer {
	mock := &Closer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Closer is an autogenerated mock type for the Closer type
type Closer struct {
	mock.Mock
}

type Closer_Expecter struct {
	mock *mock.Mock
}

func (_m *Closer) EXPECT() *Closer_Expecter {
	return &Closer_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type Closer
func (_mock *Closer) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Closer_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type Closer_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *Closer_Expecter) Close() *Closer_Close_Call {
	return &Closer_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *Closer_Close_Call) Run(run func()) *Closer_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Closer_Close_Call) Return(err error) *Closer_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Closer_Close_Call) RunAndReturn(run func() error) *Closer_Close_Call {
	_c.Call.Return(run)
	return _c
}

// NewGetterCloser creates a new instance of GetterCloser. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGetterCloser(t interface {
	mock.TestingT
	Cleanup(func())
}) *GetterCloser {
	mock := &GetterCloser{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// GetterCloser is an autogenerated mock type for the GetterCloser type
type GetterCloser struct {
	mock.Mock
}

type GetterCloser_Expecter struct {
	mock *mock.Mock
}

func (_m *GetterCloser) EXPECT() *GetterCloser_Expecter {
	return &GetterCloser_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type GetterCloser
func (_mock *GetterCloser) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// GetterCloser_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type GetterCloser_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *GetterCloser_Expecter) Close() *GetterCloser_Close_Call {
	return &GetterCloser_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *GetterCloser_Close_Call) Run(run func()) *GetterCloser_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *GetterCloser_Close_Call) Return(err error) *GetterCloser_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *GetterCloser_Close_Call) RunAndReturn(run func() error) *GetterCloser_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type GetterCloser
func (_mock *GetterCloser) Get(key []byte) ([]byte, error) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) ([]byte, error)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// GetterCloser_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type GetterCloser_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key []byte
func (_e *GetterCloser_Expecter) Get(key interface{}) *GetterCloser_Get_Call {
	return &GetterCloser_Get_Call{Call: _e.mock.On("Get", key)}
}

func (_c *GetterCloser_Get_Call) Run(run func(key []byte)) *GetterCloser_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GetterCloser_Get_Call) Return(value []byte, err error) *GetterCloser_Get_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *GetterCloser_Get_Call) RunAndReturn(run func(key []byte) ([]byte, error)) *GetterCloser_Get_Call {
	_c.Call.Return(run)
	return _c
}

// NewGetterUpdaterCloser creates a new instance of GetterUpdaterCloser. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGetterUpdaterCloser(t interface {
	mock.TestingT
	Cleanup(func())
}) *GetterUpdaterCloser {
	mock := &GetterUpdaterCloser{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// GetterUpdaterCloser is an autogenerated mock type for the GetterUpdaterCloser type
type GetterUpdaterCloser struct {
	mock.Mock
}

type GetterUpdaterCloser_Expecter struct {
	mock *mock.Mock
}

func (_m *GetterUpdaterCloser) EXPECT() *GetterUpdaterCloser_Expecter {
	return &GetterUpdaterCloser_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type GetterUpdaterCloser
func (_mock *GetterUpdaterCloser) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// GetterUpdaterCloser_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type GetterUpdaterCloser_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *GetterUpdaterCloser_Expecter) Close() *GetterUpdaterCloser_Close_Call {
	return &GetterUpdaterCloser_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *GetterUpdaterCloser_Close_Call) Run(run func()) *GetterUpdaterCloser_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *GetterUpdaterCloser_Close_Call) Return(err error) *GetterUpdaterCloser_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *GetterUpdaterCloser_Close_Call) RunAndReturn(run func() error) *GetterUpdaterCloser_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type GetterUpdaterCloser
func (_mock *GetterUpdaterCloser) Get(key []byte) ([]byte, error) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) ([]byte, error)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// GetterUpdaterCloser_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type GetterUpdaterCloser_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key []byte
func (_e *GetterUpdaterCloser_Expecter) Get(key interface{}) *GetterUpdaterCloser_Get_Call {
	return &GetterUpdaterCloser_Get_Call{Call: _e.mock.On("Get", key)}
}

func (_c *GetterUpdaterCloser_Get_Call) Run(run func(key []byte)) *GetterUpdaterCloser_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GetterUpdaterCloser_Get_Call) Return(value []byte, err error) *GetterUpdaterCloser_Get_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *GetterUpdaterCloser_Get_Call) RunAndReturn(run func(key []byte) ([]byte, error)) *GetterUpdaterCloser_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type GetterUpdaterCloser
func (_mock *GetterUpdaterCloser) Update(kvPairs map[string]string) ([]string, error) {
	ret := _mock.Called(kvPairs)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(map[string]string) ([]string, error)); ok {
		return returnFunc(kvPairs)
	}
	if returnFunc, ok := ret.Get(0).(func(map[string]string) []string); ok {
		r0 = returnFunc(kvPairs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(map[string]string) error); ok {
		r1 = returnFunc(kvPairs)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// GetterUpdaterCloser_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type GetterUpdaterCloser_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - kvPairs map[string]string
func (_e *GetterUpdaterCloser_Expecter) Update(kvPairs interface{}) *GetterUpdaterCloser_Update_Call {
	return &GetterUpdaterCloser_Update_Call{Call: _e.mock.On("Update", kvPairs)}
}

func (_c *GetterUpdaterCloser_Update_Call) Run(run func(kvPairs map[string]string)) *GetterUpdaterCloser_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 map[string]string
		if args[0] != nil {
			arg0 = args[0].(map[string]string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GetterUpdaterCloser_Update_Call) Return(strings []string, err error) *GetterUpdaterCloser_Update_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *GetterUpdaterCloser_Update_Call) RunAndReturn(run func(kvPairs map[string]string) ([]string, error)) *GetterUpdaterCloser_Update_Call {
	_c.Call.Return(run)
	return _c
}

// NewGetterSetterDeleter creates a new instance of GetterSetterDeleter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGetterSetterDeleter(t interface {
	mock.TestingT
	Cleanup(func())
}) *GetterSetterDeleter {
	mock := &GetterSetterDeleter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// GetterSetterDeleter is an autogenerated mock type for the GetterSetterDeleter type
type GetterSetterDeleter struct {
	mock.Mock
}

type GetterSetterDeleter_Expecter struct {
	mock *mock.Mock
}

func (_m *GetterSetterDeleter) EXPECT() *GetterSetterDeleter_Expecter {
	return &GetterSetterDeleter_Expecter{mock: &_m.Mock}
}

// Delete provides a mock function for the type GetterSetterDeleter
func (_mock *GetterSetterDeleter) Delete(keys ...[]byte) error {
	// []byte
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(...[]byte) error); ok {
		r0 = returnFunc(keys...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// GetterSetterDeleter_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type GetterSetterDeleter_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - keys ...[]byte
func (_e *GetterSetterDeleter_Expecter) Delete(keys ...interface{}) *GetterSetterDeleter_Delete_Call {
	return &GetterSetterDeleter_Delete_Call{Call: _e.mock.On("Delete",
		append([]interface{}{}, keys...)...)}
}

func (_c *GetterSetterDeleter_Delete_Call) Run(run func(keys ...[]byte)) *GetterSetterDeleter_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 [][]byte
		variadicArgs := make([][]byte, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.([]byte)
			}
		}
		arg0 = variadicArgs
		run(
			arg0...,
		)
	})
	return _c
}

func (_c *GetterSetterDeleter_Delete_Call) Return(err error) *GetterSetterDeleter_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *GetterSetterDeleter_Delete_Call) RunAndReturn(run func(keys ...[]byte) error) *GetterSetterDeleter_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAll provides a mock function for the type GetterSetterDeleter
func (_mock *GetterSetterDeleter) DeleteAll() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for DeleteAll")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// GetterSetterDeleter_DeleteAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAll'
type GetterSetterDeleter_DeleteAll_Call struct {
	*mock.Call
}

// DeleteAll is a helper method to define mock.On call
func (_e *GetterSetterDeleter_Expecter) DeleteAll() *GetterSetterDeleter_DeleteAll_Call {
	return &GetterSetterDeleter_DeleteAll_Call{Call: _e.mock.On("DeleteAll")}
}

func (_c *GetterSetterDeleter_DeleteAll_Call) Run(run func()) *GetterSetterDeleter_DeleteAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *GetterSetterDeleter_DeleteAll_Call) Return(err error) *GetterSetterDeleter_DeleteAll_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *GetterSetterDeleter_DeleteAll_Call) RunAndReturn(run func() error) *GetterSetterDeleter_DeleteAll_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type GetterSetterDeleter
func (_mock *GetterSetterDeleter) Get(key []byte) ([]byte, error) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) ([]byte, error)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// GetterSetterDeleter_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type GetterSetterDeleter_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key []byte
func (_e *GetterSetterDeleter_Expecter) Get(key interface{}) *GetterSetterDeleter_Get_Call {
	return &GetterSetterDeleter_Get_Call{Call: _e.mock.On("Get", key)}
}

func (_c *GetterSetterDeleter_Get_Call) Run(run func(key []byte)) *GetterSetterDeleter_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GetterSetterDeleter_Get_Call) Return(value []byte, err error) *GetterSetterDeleter_Get_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *GetterSetterDeleter_Get_Call) RunAndReturn(run func(key []byte) ([]byte, error)) *GetterSetterDeleter_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Set provides a mock function for the type GetterSetterDeleter
func (_mock *GetterSetterDeleter) Set(key []byte, value []byte) error {
	ret := _mock.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for Set")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) error); ok {
		r0 = returnFunc(key, value)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// GetterSetterDeleter_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type GetterSetterDeleter_Set_Call struct {
	*mock.Call
}

// Set is a helper method to define mock.On call
//   - key []byte
//   - value []byte
func (_e *GetterSetterDeleter_Expecter) Set(key interface{}, value interface{}) *GetterSetterDeleter_Set_Call {
	return &GetterSetterDeleter_Set_Call{Call: _e.mock.On("Set", key, value)}
}

func (_c *GetterSetterDeleter_Set_Call) Run(run func(key []byte, value []byte)) *GetterSetterDeleter_Set_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *GetterSetterDeleter_Set_Call) Return(err error) *GetterSetterDeleter_Set_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *GetterSetterDeleter_Set_Call) RunAndReturn(run func(key []byte, value []byte) error) *GetterSetterDeleter_Set_Call {
	_c.Call.Return(run)
	return _c
}

// NewGetterSetterDeleterIterator creates a new instance of GetterSetterDeleterIterator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGetterSetterDeleterIterator(t interface {
	mock.TestingT
	Cleanup(func())
}) *GetterSetterDeleterIterator {
	mock := &GetterSetterDeleterIterator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// GetterSetterDeleterIterator is an autogenerated mock type for the GetterSetterDeleterIterator type
type GetterSetterDeleterIterator struct {
	mock.Mock
}

type GetterSetterDeleterIterator_Expecter struct {
	mock *mock.Mock
}

func (_m *GetterSetterDeleterIterator) EXPECT() *GetterSetterDeleterIterator_Expecter {
	return &GetterSetterDeleterIterator_Expecter{mock: &_m.Mock}
}

// Delete provides a mock function for the type GetterSetterDeleterIterator
func (_mock *GetterSetterDeleterIterator) Delete(keys ...[]byte) error {
	// []byte
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(...[]byte) error); ok {
		r0 = returnFunc(keys...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// GetterSetterDeleterIterator_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type GetterSetterDeleterIterator_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - keys ...[]byte
func (_e *GetterSetterDeleterIterator_Expecter) Delete(keys ...interface{}) *GetterSetterDeleterIterator_Delete_Call {
	return &GetterSetterDeleterIterator_Delete_Call{Call: _e.mock.On("Delete",
		append([]interface{}{}, keys...)...)}
}

func (_c *GetterSetterDeleterIterator_Delete_Call) Run(run func(keys ...[]byte)) *GetterSetterDeleterIterator_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 [][]byte
		variadicArgs := make([][]byte, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.([]byte)
			}
		}
		arg0 = variadicArgs
		run(
			arg0...,
		)
	})
	return _c
}

func (_c *GetterSetterDeleterIterator_Delete_Call) Return(err error) *GetterSetterDeleterIterator_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *GetterSetterDeleterIterator_Delete_Call) RunAndReturn(run func(keys ...[]byte) error) *GetterSetterDeleterIterator_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAll provides a mock function for the type GetterSetterDeleterIterator
func (_mock *GetterSetterDeleterIterator) DeleteAll() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for DeleteAll")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// GetterSetterDeleterIterator_DeleteAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAll'
type GetterSetterDeleterIterator_DeleteAll_Call struct {
	*mock.Call
}

// DeleteAll is a helper method to define mock.On call
func (_e *GetterSetterDeleterIterator_Expecter) DeleteAll() *GetterSetterDeleterIterator_DeleteAll_Call {
	return &GetterSetterDeleterIterator_DeleteAll_Call{Call: _e.mock.On("DeleteAll")}
}

func (_c *GetterSetterDeleterIterator_DeleteAll_Call) Run(run func()) *GetterSetterDeleterIterator_DeleteAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *GetterSetterDeleterIterator_DeleteAll_Call) Return(err error) *GetterSetterDeleterIterator_DeleteAll_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *GetterSetterDeleterIterator_DeleteAll_Call) RunAndReturn(run func() error) *GetterSetterDeleterIterator_DeleteAll_Call {
	_c.Call.Return(run)
	return _c
}

// ForEach provides a mock function for the type GetterSetterDeleterIterator
func (_mock *GetterSetterDeleterIterator) ForEach(fn func(k []byte, v []byte) error) error {
	ret := _mock.Called(fn)

	if len(ret) == 0 {
		panic("no return value specified for ForEach")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(func(k []byte, v []byte) error) error); ok {
		r0 = returnFunc(fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// GetterSetterDeleterIterator_ForEach_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForEach'
type GetterSetterDeleterIterator_ForEach_Call struct {
	*mock.Call
}

// ForEach is a helper method to define mock.On call
//   - fn func(k []byte, v []byte) error
func (_e *GetterSetterDeleterIterator_Expecter) ForEach(fn interface{}) *GetterSetterDeleterIterator_ForEach_Call {
	return &GetterSetterDeleterIterator_ForEach_Call{Call: _e.mock.On("ForEach", fn)}
}

func (_c *GetterSetterDeleterIterator_ForEach_Call) Run(run func(fn func(k []byte, v []byte) error)) *GetterSetterDeleterIterator_ForEach_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func(k []byte, v []byte) error
		if args[0] != nil {
			arg0 = args[0].(func(k []byte, v []byte) error)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GetterSetterDeleterIterator_ForEach_Call) Return(err error) *GetterSetterDeleterIterator_ForEach_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *GetterSetterDeleterIterator_ForEach_Call) RunAndReturn(run func(fn func(k []byte, v []byte) error) error) *GetterSetterDeleterIterator_ForEach_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type GetterSetterDeleterIterator
func (_mock *GetterSetterDeleterIterator) Get(key []byte) ([]byte, error) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) ([]byte, error)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// GetterSetterDeleterIterator_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type GetterSetterDeleterIterator_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key []byte
func (_e *GetterSetterDeleterIterator_Expecter) Get(key interface{}) *GetterSetterDeleterIterator_Get_Call {
	return &GetterSetterDeleterIterator_Get_Call{Call: _e.mock.On("Get", key)}
}

func (_c *GetterSetterDeleterIterator_Get_Call) Run(run func(key []byte)) *GetterSetterDeleterIterator_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GetterSetterDeleterIterator_Get_Call) Return(value []byte, err error) *GetterSetterDeleterIterator_Get_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *GetterSetterDeleterIterator_Get_Call) RunAndReturn(run func(key []byte) ([]byte, error)) *GetterSetterDeleterIterator_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Set provides a mock function for the type GetterSetterDeleterIterator
func (_mock *GetterSetterDeleterIterator) Set(key []byte, value []byte) error {
	ret := _mock.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for Set")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) error); ok {
		r0 = returnFunc(key, value)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// GetterSetterDeleterIterator_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type GetterSetterDeleterIterator_Set_Call struct {
	*mock.Call
}

// Set is a helper method to define mock.On call
//   - key []byte
//   - value []byte
func (_e *GetterSetterDeleterIterator_Expecter) Set(key interface{}, value interface{}) *GetterSetterDeleterIterator_Set_Call {
	return &GetterSetterDeleterIterator_Set_Call{Call: _e.mock.On("Set", key, value)}
}

func (_c *GetterSetterDeleterIterator_Set_Call) Run(run func(key []byte, value []byte)) *GetterSetterDeleterIterator_Set_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *GetterSetterDeleterIterator_Set_Call) Return(err error) *GetterSetterDeleterIterator_Set_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *GetterSetterDeleterIterator_Set_Call) RunAndReturn(run func(key []byte, value []byte) error) *GetterSetterDeleterIterator_Set_Call {
	_c.Call.Return(run)
	return _c
}

// NewGetterSetterDeleterIteratorUpdaterCounterAppender creates a new instance of GetterSetterDeleterIteratorUpdaterCounterAppender. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGetterSetterDeleterIteratorUpdaterCounterAppender(t interface {
	mock.TestingT
	Cleanup(func())
}) *GetterSetterDeleterIteratorUpdaterCounterAppender {
	mock := &GetterSetterDeleterIteratorUpdaterCounterAppender{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// GetterSetterDeleterIteratorUpdaterCounterAppender is an autogenerated mock type for the GetterSetterDeleterIteratorUpdaterCounterAppender type
type GetterSetterDeleterIteratorUpdaterCounterAppender struct {
	mock.Mock
}

type GetterSetterDeleterIteratorUpdaterCounterAppender_Expecter struct {
	mock *mock.Mock
}

func (_m *GetterSetterDeleterIteratorUpdaterCounterAppender) EXPECT() *GetterSetterDeleterIteratorUpdaterCounterAppender_Expecter {
	return &GetterSetterDeleterIteratorUpdaterCounterAppender_Expecter{mock: &_m.Mock}
}

// AppendValues provides a mock function for the type GetterSetterDeleterIteratorUpdaterCounterAppender
func (_mock *GetterSetterDeleterIteratorUpdaterCounterAppender) AppendValues(values ...[]byte) error {
	// []byte
	_va := make([]interface{}, len(values))
	for _i := range values {
		_va[_i] = values[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AppendValues")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(...[]byte) error); ok {
		r0 = returnFunc(values...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// GetterSetterDeleterIteratorUpdaterCounterAppender_AppendValues_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AppendValues'
type GetterSetterDeleterIteratorUpdaterCounterAppender_AppendValues_Call struct {
	*mock.Call
}

// AppendValues is a helper method to define mock.On call
//   - values ...[]byte
func (_e *GetterSetterDeleterIteratorUpdaterCounterAppender_Expecter) AppendValues(values ...interface{}) *GetterSetterDeleterIteratorUpdaterCounterAppender_AppendValues_Call {
	return &GetterSetterDeleterIteratorUpdaterCounterAppender_AppendValues_Call{Call: _e.mock.On("AppendValues",
		append([]interface{}{}, values...)...)}
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_AppendValues_Call) Run(run func(values ...[]byte)) *GetterSetterDeleterIteratorUpdaterCounterAppender_AppendValues_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 [][]byte
		variadicArgs := make([][]byte, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.([]byte)
			}
		}
		arg0 = variadicArgs
		run(
			arg0...,
		)
	})
	return _c
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_AppendValues_Call) Return(err error) *GetterSetterDeleterIteratorUpdaterCounterAppender_AppendValues_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_AppendValues_Call) RunAndReturn(run func(values ...[]byte) error) *GetterSetterDeleterIteratorUpdaterCounterAppender_AppendValues_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type GetterSetterDeleterIteratorUpdaterCounterAppender
func (_mock *GetterSetterDeleterIteratorUpdaterCounterAppender) Count() (int, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (int, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// GetterSetterDeleterIteratorUpdaterCounterAppender_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type GetterSetterDeleterIteratorUpdaterCounterAppender_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
func (_e *GetterSetterDeleterIteratorUpdaterCounterAppender_Expecter) Count() *GetterSetterDeleterIteratorUpdaterCounterAppender_Count_Call {
	return &GetterSetterDeleterIteratorUpdaterCounterAppender_Count_Call{Call: _e.mock.On("Count")}
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_Count_Call) Run(run func()) *GetterSetterDeleterIteratorUpdaterCounterAppender_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_Count_Call) Return(n int, err error) *GetterSetterDeleterIteratorUpdaterCounterAppender_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_Count_Call) RunAndReturn(run func() (int, error)) *GetterSetterDeleterIteratorUpdaterCounterAppender_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type GetterSetterDeleterIteratorUpdaterCounterAppender
func (_mock *GetterSetterDeleterIteratorUpdaterCounterAppender) Delete(keys ...[]byte) error {
	// []byte
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(...[]byte) error); ok {
		r0 = returnFunc(keys...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// GetterSetterDeleterIteratorUpdaterCounterAppender_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type GetterSetterDeleterIteratorUpdaterCounterAppender_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - keys ...[]byte
func (_e *GetterSetterDeleterIteratorUpdaterCounterAppender_Expecter) Delete(keys ...interface{}) *GetterSetterDeleterIteratorUpdaterCounterAppender_Delete_Call {
	return &GetterSetterDeleterIteratorUpdaterCounterAppender_Delete_Call{Call: _e.mock.On("Delete",
		append([]interface{}{}, keys...)...)}
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_Delete_Call) Run(run func(keys ...[]byte)) *GetterSetterDeleterIteratorUpdaterCounterAppender_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 [][]byte
		variadicArgs := make([][]byte, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.([]byte)
			}
		}
		arg0 = variadicArgs
		run(
			arg0...,
		)
	})
	return _c
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_Delete_Call) Return(err error) *GetterSetterDeleterIteratorUpdaterCounterAppender_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_Delete_Call) RunAndReturn(run func(keys ...[]byte) error) *GetterSetterDeleterIteratorUpdaterCounterAppender_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAll provides a mock function for the type GetterSetterDeleterIteratorUpdaterCounterAppender
func (_mock *GetterSetterDeleterIteratorUpdaterCounterAppender) DeleteAll() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for DeleteAll")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// GetterSetterDeleterIteratorUpdaterCounterAppender_DeleteAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAll'
type GetterSetterDeleterIteratorUpdaterCounterAppender_DeleteAll_Call struct {
	*mock.Call
}

// DeleteAll is a helper method to define mock.On call
func (_e *GetterSetterDeleterIteratorUpdaterCounterAppender_Expecter) DeleteAll() *GetterSetterDeleterIteratorUpdaterCounterAppender_DeleteAll_Call {
	return &GetterSetterDeleterIteratorUpdaterCounterAppender_DeleteAll_Call{Call: _e.mock.On("DeleteAll")}
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_DeleteAll_Call) Run(run func()) *GetterSetterDeleterIteratorUpdaterCounterAppender_DeleteAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_DeleteAll_Call) Return(err error) *GetterSetterDeleterIteratorUpdaterCounterAppender_DeleteAll_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_DeleteAll_Call) RunAndReturn(run func() error) *GetterSetterDeleterIteratorUpdaterCounterAppender_DeleteAll_Call {
	_c.Call.Return(run)
	return _c
}

// ForEach provides a mock function for the type GetterSetterDeleterIteratorUpdaterCounterAppender
func (_mock *GetterSetterDeleterIteratorUpdaterCounterAppender) ForEach(fn func(k []byte, v []byte) error) error {
	ret := _mock.Called(fn)

	if len(ret) == 0 {
		panic("no return value specified for ForEach")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(func(k []byte, v []byte) error) error); ok {
		r0 = returnFunc(fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// GetterSetterDeleterIteratorUpdaterCounterAppender_ForEach_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForEach'
type GetterSetterDeleterIteratorUpdaterCounterAppender_ForEach_Call struct {
	*mock.Call
}

// ForEach is a helper method to define mock.On call
//   - fn func(k []byte, v []byte) error
func (_e *GetterSetterDeleterIteratorUpdaterCounterAppender_Expecter) ForEach(fn interface{}) *GetterSetterDeleterIteratorUpdaterCounterAppender_ForEach_Call {
	return &GetterSetterDeleterIteratorUpdaterCounterAppender_ForEach_Call{Call: _e.mock.On("ForEach", fn)}
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_ForEach_Call) Run(run func(fn func(k []byte, v []byte) error)) *GetterSetterDeleterIteratorUpdaterCounterAppender_ForEach_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func(k []byte, v []byte) error
		if args[0] != nil {
			arg0 = args[0].(func(k []byte, v []byte) error)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_ForEach_Call) Return(err error) *GetterSetterDeleterIteratorUpdaterCounterAppender_ForEach_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_ForEach_Call) RunAndReturn(run func(fn func(k []byte, v []byte) error) error) *GetterSetterDeleterIteratorUpdaterCounterAppender_ForEach_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type GetterSetterDeleterIteratorUpdaterCounterAppender
func (_mock *GetterSetterDeleterIteratorUpdaterCounterAppender) Get(key []byte) ([]byte, error) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) ([]byte, error)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// GetterSetterDeleterIteratorUpdaterCounterAppender_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type GetterSetterDeleterIteratorUpdaterCounterAppender_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key []byte
func (_e *GetterSetterDeleterIteratorUpdaterCounterAppender_Expecter) Get(key interface{}) *GetterSetterDeleterIteratorUpdaterCounterAppender_Get_Call {
	return &GetterSetterDeleterIteratorUpdaterCounterAppender_Get_Call{Call: _e.mock.On("Get", key)}
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_Get_Call) Run(run func(key []byte)) *GetterSetterDeleterIteratorUpdaterCounterAppender_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_Get_Call) Return(value []byte, err error) *GetterSetterDeleterIteratorUpdaterCounterAppender_Get_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_Get_Call) RunAndReturn(run func(key []byte) ([]byte, error)) *GetterSetterDeleterIteratorUpdaterCounterAppender_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Set provides a mock function for the type GetterSetterDeleterIteratorUpdaterCounterAppender
func (_mock *GetterSetterDeleterIteratorUpdaterCounterAppender) Set(key []byte, value []byte) error {
	ret := _mock.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for Set")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) error); ok {
		r0 = returnFunc(key, value)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// GetterSetterDeleterIteratorUpdaterCounterAppender_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type GetterSetterDeleterIteratorUpdaterCounterAppender_Set_Call struct {
	*mock.Call
}

// Set is a helper method to define mock.On call
//   - key []byte
//   - value []byte
func (_e *GetterSetterDeleterIteratorUpdaterCounterAppender_Expecter) Set(key interface{}, value interface{}) *GetterSetterDeleterIteratorUpdaterCounterAppender_Set_Call {
	return &GetterSetterDeleterIteratorUpdaterCounterAppender_Set_Call{Call: _e.mock.On("Set", key, value)}
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_Set_Call) Run(run func(key []byte, value []byte)) *GetterSetterDeleterIteratorUpdaterCounterAppender_Set_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_Set_Call) Return(err error) *GetterSetterDeleterIteratorUpdaterCounterAppender_Set_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_Set_Call) RunAndReturn(run func(key []byte, value []byte) error) *GetterSetterDeleterIteratorUpdaterCounterAppender_Set_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type GetterSetterDeleterIteratorUpdaterCounterAppender
func (_mock *GetterSetterDeleterIteratorUpdaterCounterAppender) Update(kvPairs map[string]string) ([]string, error) {
	ret := _mock.Called(kvPairs)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(map[string]string) ([]string, error)); ok {
		return returnFunc(kvPairs)
	}
	if returnFunc, ok := ret.Get(0).(func(map[string]string) []string); ok {
		r0 = returnFunc(kvPairs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(map[string]string) error); ok {
		r1 = returnFunc(kvPairs)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// GetterSetterDeleterIteratorUpdaterCounterAppender_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type GetterSetterDeleterIteratorUpdaterCounterAppender_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - kvPairs map[string]string
func (_e *GetterSetterDeleterIteratorUpdaterCounterAppender_Expecter) Update(kvPairs interface{}) *GetterSetterDeleterIteratorUpdaterCounterAppender_Update_Call {
	return &GetterSetterDeleterIteratorUpdaterCounterAppender_Update_Call{Call: _e.mock.On("Update", kvPairs)}
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_Update_Call) Run(run func(kvPairs map[string]string)) *GetterSetterDeleterIteratorUpdaterCounterAppender_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 map[string]string
		if args[0] != nil {
			arg0 = args[0].(map[string]string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_Update_Call) Return(strings []string, err error) *GetterSetterDeleterIteratorUpdaterCounterAppender_Update_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *GetterSetterDeleterIteratorUpdaterCounterAppender_Update_Call) RunAndReturn(run func(kvPairs map[string]string) ([]string, error)) *GetterSetterDeleterIteratorUpdaterCounterAppender_Update_Call {
	_c.Call.Return(run)
	return _c
}

// NewKVStore creates a new instance of KVStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKVStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *KVStore {
	mock := &KVStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KVStore is an autogenerated mock type for the KVStore type
type KVStore struct {
	mock.Mock
}

type KVStore_Expecter struct {
	mock *mock.Mock
}

func (_m *KVStore) EXPECT() *KVStore_Expecter {
	return &KVStore_Expecter{mock: &_m.Mock}
}

// AppendValues provides a mock function for the type KVStore
func (_mock *KVStore) AppendValues(values ...[]byte) error {
	// []byte
	_va := make([]interface{}, len(values))
	for _i := range values {
		_va[_i] = values[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AppendValues")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(...[]byte) error); ok {
		r0 = returnFunc(values...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KVStore_AppendValues_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AppendValues'
type KVStore_AppendValues_Call struct {
	*mock.Call
}

// AppendValues is a helper method to define mock.On call
//   - values ...[]byte
func (_e *KVStore_Expecter) AppendValues(values ...interface{}) *KVStore_AppendValues_Call {
	return &KVStore_AppendValues_Call{Call: _e.mock.On("AppendValues",
		append([]interface{}{}, values...)...)}
}

func (_c *KVStore_AppendValues_Call) Run(run func(values ...[]byte)) *KVStore_AppendValues_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 [][]byte
		variadicArgs := make([][]byte, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.([]byte)
			}
		}
		arg0 = variadicArgs
		run(
			arg0...,
		)
	})
	return _c
}

func (_c *KVStore_AppendValues_Call) Return(err error) *KVStore_AppendValues_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *KVStore_AppendValues_Call) RunAndReturn(run func(values ...[]byte) error) *KVStore_AppendValues_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type KVStore
func (_mock *KVStore) Count() (int, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (int, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// KVStore_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type KVStore_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
func (_e *KVStore_Expecter) Count() *KVStore_Count_Call {
	return &KVStore_Count_Call{Call: _e.mock.On("Count")}
}

func (_c *KVStore_Count_Call) Run(run func()) *KVStore_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_Count_Call) Return(n int, err error) *KVStore_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *KVStore_Count_Call) RunAndReturn(run func() (int, error)) *KVStore_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type KVStore
func (_mock *KVStore) Delete(keys ...[]byte) error {
	// []byte
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(...[]byte) error); ok {
		r0 = returnFunc(keys...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KVStore_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type KVStore_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - keys ...[]byte
func (_e *KVStore_Expecter) Delete(keys ...interface{}) *KVStore_Delete_Call {
	return &KVStore_Delete_Call{Call: _e.mock.On("Delete",
		append([]interface{}{}, keys...)...)}
}

func (_c *KVStore_Delete_Call) Run(run func(keys ...[]byte)) *KVStore_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 [][]byte
		variadicArgs := make([][]byte, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.([]byte)
			}
		}
		arg0 = variadicArgs
		run(
			arg0...,
		)
	})
	return _c
}

func (_c *KVStore_Delete_Call) Return(err error) *KVStore_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *KVStore_Delete_Call) RunAndReturn(run func(keys ...[]byte) error) *KVStore_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAll provides a mock function for the type KVStore
func (_mock *KVStore) DeleteAll() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for DeleteAll")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KVStore_DeleteAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAll'
type KVStore_DeleteAll_Call struct {
	*mock.Call
}

// DeleteAll is a helper method to define mock.On call
func (_e *KVStore_Expecter) DeleteAll() *KVStore_DeleteAll_Call {
	return &KVStore_DeleteAll_Call{Call: _e.mock.On("DeleteAll")}
}

func (_c *KVStore_DeleteAll_Call) Run(run func()) *KVStore_DeleteAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_DeleteAll_Call) Return(err error) *KVStore_DeleteAll_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *KVStore_DeleteAll_Call) RunAndReturn(run func() error) *KVStore_DeleteAll_Call {
	_c.Call.Return(run)
	return _c
}

// ForEach provides a mock function for the type KVStore
func (_mock *KVStore) ForEach(fn func(k []byte, v []byte) error) error {
	ret := _mock.Called(fn)

	if len(ret) == 0 {
		panic("no return value specified for ForEach")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(func(k []byte, v []byte) error) error); ok {
		r0 = returnFunc(fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KVStore_ForEach_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForEach'
type KVStore_ForEach_Call struct {
	*mock.Call
}

// ForEach is a helper method to define mock.On call
//   - fn func(k []byte, v []byte) error
func (_e *KVStore_Expecter) ForEach(fn interface{}) *KVStore_ForEach_Call {
	return &KVStore_ForEach_Call{Call: _e.mock.On("ForEach", fn)}
}

func (_c *KVStore_ForEach_Call) Run(run func(fn func(k []byte, v []byte) error)) *KVStore_ForEach_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func(k []byte, v []byte) error
		if args[0] != nil {
			arg0 = args[0].(func(k []byte, v []byte) error)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *KVStore_ForEach_Call) Return(err error) *KVStore_ForEach_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *KVStore_ForEach_Call) RunAndReturn(run func(fn func(k []byte, v []byte) error) error) *KVStore_ForEach_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type KVStore
func (_mock *KVStore) Get(key []byte) ([]byte, error) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) ([]byte, error)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// KVStore_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type KVStore_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key []byte
func (_e *KVStore_Expecter) Get(key interface{}) *KVStore_Get_Call {
	return &KVStore_Get_Call{Call: _e.mock.On("Get", key)}
}

func (_c *KVStore_Get_Call) Run(run func(key []byte)) *KVStore_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *KVStore_Get_Call) Return(value []byte, err error) *KVStore_Get_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *KVStore_Get_Call) RunAndReturn(run func(key []byte) ([]byte, error)) *KVStore_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Set provides a mock function for the type KVStore
func (_mock *KVStore) Set(key []byte, value []byte) error {
	ret := _mock.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for Set")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) error); ok {
		r0 = returnFunc(key, value)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KVStore_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type KVStore_Set_Call struct {
	*mock.Call
}

// Set is a helper method to define mock.On call
//   - key []byte
//   - value []byte
func (_e *KVStore_Expecter) Set(key interface{}, value interface{}) *KVStore_Set_Call {
	return &KVStore_Set_Call{Call: _e.mock.On("Set", key, value)}
}

func (_c *KVStore_Set_Call) Run(run func(key []byte, value []byte)) *KVStore_Set_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *KVStore_Set_Call) Return(err error) *KVStore_Set_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *KVStore_Set_Call) RunAndReturn(run func(key []byte, value []byte) error) *KVStore_Set_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type KVStore
func (_mock *KVStore) Update(kvPairs map[string]string) ([]string, error) {
	ret := _mock.Called(kvPairs)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(map[string]string) ([]string, error)); ok {
		return returnFunc(kvPairs)
	}
	if returnFunc, ok := ret.Get(0).(func(map[string]string) []string); ok {
		r0 = returnFunc(kvPairs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(map[string]string) error); ok {
		r1 = returnFunc(kvPairs)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// KVStore_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type KVStore_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - kvPairs map[string]string
func (_e *KVStore_Expecter) Update(kvPairs interface{}) *KVStore_Update_Call {
	return &KVStore_Update_Call{Call: _e.mock.On("Update", kvPairs)}
}

func (_c *KVStore_Update_Call) Run(run func(kvPairs map[string]string)) *KVStore_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 map[string]string
		if args[0] != nil {
			arg0 = args[0].(map[string]string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *KVStore_Update_Call) Return(strings []string, err error) *KVStore_Update_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *KVStore_Update_Call) RunAndReturn(run func(kvPairs map[string]string) ([]string, error)) *KVStore_Update_Call {
	_c.Call.Return(run)
	return _c
}
