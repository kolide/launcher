// Code generated by go-bindata. DO NOT EDIT.
// sources:
// assets/lenses/access.aug
// assets/lenses/apt_update_manager.aug
// assets/lenses/aptcacherngsecurity.aug
// assets/lenses/aptconf.aug
// assets/lenses/aptpreferences.aug
// assets/lenses/aptsources.aug
// assets/lenses/build.aug
// assets/lenses/crypttab.aug
// assets/lenses/dpkg.aug
// assets/lenses/inifile.aug
// assets/lenses/lightdm.aug
// assets/lenses/lvm.aug
// assets/lenses/nsswitch.aug
// assets/lenses/pam.aug
// assets/lenses/pamconf.aug
// assets/lenses/passwd.aug
// assets/lenses/quote.aug
// assets/lenses/rx.aug
// assets/lenses/sep.aug
// assets/lenses/sudoers.aug
// assets/lenses/util.aug
// assets/lenses/yum.aug
package augeas

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
)
type asset struct {
	bytes []byte
	info  os.FileInfo
}

type bindataFileInfo struct {
	name    string
	size    int64
	mode    os.FileMode
	modTime time.Time
}

func (fi bindataFileInfo) Name() string {
	return fi.name
}
func (fi bindataFileInfo) Size() int64 {
	return fi.size
}
func (fi bindataFileInfo) Mode() os.FileMode {
	return fi.mode
}
func (fi bindataFileInfo) ModTime() time.Time {
	return fi.modTime
}
func (fi bindataFileInfo) IsDir() bool {
	return false
}
func (fi bindataFileInfo) Sys() interface{} {
	return nil
}

var _assetsLensesAccessAug = []byte(`(* 
Module: Access
  Parses /etc/security/access.conf

Author: Lorenzo Dalrio <lorenzo.dalrio@gmail.com>

About: Reference
  Some examples of valid entries can be found in access.conf or "man access.conf"

About: License
  This file is licensed under the LGPL v2+, like the rest of Augeas.

About: Lens Usage
  Sample usage of this lens in augtool

  * Add a rule to permit login of all users from local sources (tty's, X, cron)
  > set /files/etc/security/access.conf[0] +
  > set /files/etc/security/access.conf[0]/user ALL
  > set /files/etc/security/access.conf[0]/origin LOCAL

About: Configuration files
  This lens applies to /etc/security/access.conf. See <filter>.

About: Examples
   The <Test_Access> file contains various examples and tests.
*)
module Access =
  autoload xfm

(* Group: Comments and empty lines *)
(* Variable: comment *)
let comment   = Util.comment
(* Variable: empty *)
let empty     = Util.empty

(* Group: Useful primitives *)
(* Variable: colon
 *  this is the standard field separator " : "
 *)
let colon     = del (Rx.opt_space . ":" . Rx.opt_space) " : "


(************************************************************************
 * Group:                     ENTRY LINE
  *************************************************************************)
(* View: access
 * Allow (+) or deny (-) access
 *)
let access    = label "access" . store /[+-]/

(* Variable: identifier_re
   Regex for user/group identifiers *)
let identifier_re = /[A-Za-z0-9_.\\-]+/

(* View: user_re
 * Regex for user/netgroup fields
 *)
let user_re = identifier_re - /[Ee][Xx][Cc][Ee][Pp][Tt]/

(* View: user
 * user can be a username, username@hostname or a group
 *)
let user      = [ label "user"
                . ( store user_re
                  | store Rx.word . Util.del_str "@"
                    . [ label "host" . store Rx.word ] ) ]

(* View: group
 * Format is (GROUP)
 *)
let group     = [ label "group"
                  . Util.del_str "(" . store identifier_re . Util.del_str ")" ]

(* View: netgroup
 * Format is @NETGROUP[@@NISDOMAIN]
 *)
let netgroup =
    [ label "netgroup" . Util.del_str "@" . store user_re
      . [ label "nisdomain" . Util.del_str "@@" . store Rx.word ]? ]

(* View: user_list
 * A list of users or netgroups to apply the rule to
 *)
let user_list = Build.opt_list (user|group|netgroup) Sep.space

(* View: origin_list
 * origin_list can be a single ipaddr/originname/domain/fqdn or a list of those values
 *)
let origin_list = 
   let origin_re = Rx.no_spaces - /[Ee][Xx][Cc][Ee][Pp][Tt]/
   in Build.opt_list [ label "origin" . store origin_re ] Sep.space

(* View: except
 * The except operator makes it possible to write very compact rules. 
 *)
let except (lns:lens) = [ label "except" . Sep.space
                        . del /[Ee][Xx][Cc][Ee][Pp][Tt]/ "EXCEPT"
                        . Sep.space . lns ]

(* View: entry 
 * A valid entry line
 * Definition:
 *   > entry ::= access ':' user ':' origin_list
 *)
let entry     = [ access . colon
                . user_list
                . (except user_list)?
                . colon
                . origin_list
                . (except origin_list)?
                . Util.eol ]

(************************************************************************
 * Group:                        LENS & FILTER
  *************************************************************************)
(* View: lns
    The access.conf lens, any amount of
      * <empty> lines
      * <comments>
      * <entry>
*)
let lns       = (comment|empty|entry) *

(* Variable: filter *)
let filter    = incl "/etc/security/access.conf"

(* xfm *)
let xfm       = transform lns filter
`)

func assetsLensesAccessAugBytes() ([]byte, error) {
	return _assetsLensesAccessAug, nil
}

func assetsLensesAccessAug() (*asset, error) {
	bytes, err := assetsLensesAccessAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/access.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesApt_update_managerAug = []byte(`(*
Module: Apt_Update_Manager
  Parses files in /etc/update-manager

Author: Raphael Pinson <raphael.pinson@camptocamp.com>

About: License
   This file is licenced under the LGPL v2+, like the rest of Augeas.

About: Lens Usage
   To be documented

About: Configuration files
   This lens applies to files in /etc/update-manager. See <filter>.

About: Examples
   The <Test_Apt_Update_Manager> file contains various examples and tests.
*)
module Apt_Update_Manager =

autoload xfm

(* View: comment *)
let comment = IniFile.comment IniFile.comment_re IniFile.comment_default

(* View: sep *)
let sep = IniFile.sep IniFile.sep_re IniFile.sep_default

(* View: title *)
let title = IniFile.title Rx.word

(* View: entry *)
let entry = IniFile.entry Rx.word sep comment

(* View: record *)
let record = IniFile.record title entry

(* View: lns *)
let lns = IniFile.lns record comment

(* Variable: filter *)
let filter = incl "/etc/update-manager/meta-release"
           . incl "/etc/update-manager/release-upgrades"
           . incl "/etc/update-manager/release-upgrades.d/*"
           . Util.stdexcl

let xfm = transform lns filter
`)

func assetsLensesApt_update_managerAugBytes() ([]byte, error) {
	return _assetsLensesApt_update_managerAug, nil
}

func assetsLensesApt_update_managerAug() (*asset, error) {
	bytes, err := assetsLensesApt_update_managerAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/apt_update_manager.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesAptcacherngsecurityAug = []byte(`(* Module: AptCacherNGSecurity

   Lens for config files like the one found in
   /etc/apt-cacher-ng/security.conf


   About: License
   Copyright 2013 Erik B. Andersen; this file is licenced under the LGPL v2+.
*)
module AptCacherNGSecurity =
	autoload xfm

	(* Define a Username/PW pair *)
	let authpair = [ key /[^ \t:\/]*/ . del /:/ ":" . store /[^: \t\n]*/ ]

	(* Define a record. So far as I can tell, the only auth level supported is Admin *)
	let record = [ key "AdminAuth". del /[ \t]*:[ \t]*/ ": ". authpair . Util.del_str "\n"]

	(* Define the basic lens *)
	let lns = ( record | Util.empty | Util.comment )*

	let filter = incl "/etc/apt-cacher-ng/security.conf"
		. Util.stdexcl

	let xfm = transform lns filter
`)

func assetsLensesAptcacherngsecurityAugBytes() ([]byte, error) {
	return _assetsLensesAptcacherngsecurityAug, nil
}

func assetsLensesAptcacherngsecurityAug() (*asset, error) {
	bytes, err := assetsLensesAptcacherngsecurityAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/aptcacherngsecurity.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesAptconfAug = []byte(`(*
Module: AptConf
 Parses /etc/apt/apt.conf and /etc/apt/apt.conf.d/*

Author: Raphael Pinson <raphink@gmail.com>

About: Reference
 This lens tries to keep as close as possible to `+"`"+`man 5 apt.conf`+"`"+`
where possible.

About: License
  This file is licenced under the LGPL v2+, like the rest of Augeas.

About: Lens Usage
  To be documented

About: Configuration files
  This lens applies to /etc/apt/apt.conf and /etc/apt/apt.conf.d/*.
See <filter>.
*)


module AptConf =
 autoload xfm

(************************************************************************
 * Group:                 USEFUL PRIMITIVES
 *************************************************************************)

(* View: eol
   And <Util.eol> end of line *)
let eol = Util.eol

(* View: empty
   A C-style empty line *)
let empty = Util.empty_any

(* View: indent
   An indentation *)
let indent = Util.indent

(* View: comment_simple
   A one-line comment, C-style *)
let comment_simple = Util.comment_c_style_or_hash

(* View: comment_multi
   A multiline comment, C-style *)
let comment_multi = Util.comment_multiline

(* View: comment
   A comment, either <comment_simple> or <comment_multi> *)
let comment = comment_simple | comment_multi


(************************************************************************
 * Group:                 ENTRIES
 *************************************************************************)

(* View: name_re
   Regex for entry names *)
let name_re = /[A-Za-z][A-Za-z-]*/

(* View: name_re_colons
   Regex for entry names with colons *)
let name_re_colons = /[A-Za-z][A-Za-z:-]*/


(* View: entry
   An apt.conf entry, recursive

   WARNING:
     This lens exploits a put ambiguity
     since apt.conf allows for both
     APT { Clean-Installed { "true" } }
     and APT::Clean-Installed "true";
     but we're choosing to map them the same way

     The recursive lens doesn't seem
     to care and defaults to the first
     item in the union.

     This is why the APT { Clean-Installed { "true"; } }
     form is listed first, since it supports
     all subnodes (which Dpkg::Conf) doesn't.

     Exchanging these two expressions in the union
     makes tests fails since the tree cannot
     be mapped back.

     This situation results in existing
     configuration being modified when the
     associated tree is modified. For example,
     changing the value of
     APT::Clean-Installed "true"; to "false"
     results in
     APT { Clean-Installed "false"; }
     (see unit tests)
 *)
let rec entry_noeol =
 let value =
    Util.del_str "\"" . store /[^"\n]+/
                      . del /";?/ "\";" in
 let opt_eol = del /[ \t\n]*/ "\n" in
 let long_eol = del /[ \t]*\n+/ "\n" in
 let list_elem = [ opt_eol . label "@elem" . value ] in
 let eol_comment = del /([ \t\n]*\n)?/ "" . comment in
     [ key name_re . Sep.space . value ]
   | [ key name_re . del /[ \t\n]*\{/ " {" .
         ( (opt_eol . entry_noeol) |
           list_elem |
           eol_comment
           )* .
         del /[ \t\n]*\};?/ "\n};" ]
   | [ key name_re . Util.del_str "::" . entry_noeol ]

let entry = indent . entry_noeol . eol


(* View: include
   A file inclusion
   /!\ The manpage is not clear on the syntax *)
let include =
 [ indent . key "#include" . Sep.space
          . store Rx.fspath . eol ]


(* View: clear
   A list of variables to clear
   /!\ The manpage is not clear on the syntax *)
let clear =
 let name = [ label "name" . store name_re_colons ] in
 [ indent . key "#clear" . Sep.space
          . Build.opt_list name Sep.space
          . eol ]


(************************************************************************
 * Group:                 LENS AND FILTER
 *************************************************************************)

(* View: lns
    The apt.conf lens *)
let lns = (empty|comment|entry|include|clear)*


(* View: filter *)
let filter = incl "/etc/apt/apt.conf"
   . incl "/etc/apt/apt.conf.d/*"
   . Util.stdexcl

let xfm = transform lns filter
`)

func assetsLensesAptconfAugBytes() ([]byte, error) {
	return _assetsLensesAptconfAug, nil
}

func assetsLensesAptconfAug() (*asset, error) {
	bytes, err := assetsLensesAptconfAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/aptconf.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesAptpreferencesAug = []byte(`(*
Module: AptPreferences
  Apt/preferences module for Augeas

Author: Raphael Pinson <raphael.pinson@camptocamp.com>
*)

module AptPreferences =
autoload xfm

(************************************************************************
 * Group: Entries
 ************************************************************************)

(* View: colon *)
let colon        = del /:[ \t]*/ ": "

(* View: pin_gen
     A generic pin

   Parameters:
     lbl:string - the label *)
let pin_gen (lbl:string) = store lbl
                        . [ label lbl . Sep.space . store Rx.no_spaces ]

(* View: pin_keys *)
let pin_keys =
     let space_in = store /[^, \r\t\n][^,\n]*[^, \r\t\n]|[^, \t\n\r]/
  in Build.key_value /[aclnov]/ Sep.equal space_in

(* View: pin_options *)
let pin_options =
    let comma = Util.delim ","
 in store "release" . Sep.space
                    . Build.opt_list pin_keys comma

(* View: version_pin *)
let version_pin = pin_gen "version"

(* View: origin_pin *)
let origin_pin = pin_gen "origin"

(* View: pin *)
let pin =
     let pin_value = pin_options | version_pin | origin_pin
  in Build.key_value_line "Pin" colon pin_value

(* View: entries *)
let entries = Build.key_value_line ("Explanation"|"Package"|"Pin-Priority")
                                   colon (store Rx.space_in)
            | pin
            | Util.comment

(* View: record *)
let record = [ seq "record" . entries+ ]

(************************************************************************
 * Group: Lens
 ************************************************************************)

(* View: lns *)
let lns = Util.empty* . (Build.opt_list record Util.eol+ . Util.empty*)?

(* View: filter *)
let filter = incl "/etc/apt/preferences"
           . incl "/etc/apt/preferences.d/*"
           . Util.stdexcl

let xfm = transform lns filter
`)

func assetsLensesAptpreferencesAugBytes() ([]byte, error) {
	return _assetsLensesAptpreferencesAug, nil
}

func assetsLensesAptpreferencesAug() (*asset, error) {
	bytes, err := assetsLensesAptpreferencesAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/aptpreferences.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesAptsourcesAug = []byte(`(*
Module: Aptsources
  Parsing /etc/apt/sources.list
*)

module Aptsources =
  autoload xfm

(************************************************************************
 * Group: Utility variables/functions
 ************************************************************************)
  (* View:  sep_ws *)
  let sep_ws = Sep.space

  (* View: eol *)
  let eol = Util.del_str "\n"

  (* View: comment *)
  let comment = Util.comment
  (* View: empty *)
  let empty = Util.empty

  (* View: word *)
  let word = /[^][# \n\t]+/

  (* View: uri *)
  let uri =
       let protocol = /[a-z+]+:/
    in let path = /\/[^] \t]*/
    in let path_brack = /\[[^]]+\]\/?/
    in protocol? . path
     | protocol . path_brack

(************************************************************************
 * Group: Keywords
 ************************************************************************)
  (* View: record *)
  let record =
       let option_sep = [ label "operation" . store /[+-]/]? . Sep.equal
    in let option = Build.key_value /arch|trusted/ option_sep (store Rx.word)
    in let options = [ label "options"
                . Util.del_str "[" . Sep.opt_space
                . Build.opt_list option Sep.space
                . Sep.opt_space . Util.del_str "]"
                . sep_ws ]
    in [ Util.indent . seq "source"
       . [ label "type" . store word ] . sep_ws
       . options?
       . [ label "uri"  . store uri ] . sep_ws
       . [ label "distribution" . store word ]
       . [ label "component" . sep_ws . store word ]*
       . del /[ \t]*(#.*)?/ ""
       . eol ]

(************************************************************************
 * Group: Lens
 ************************************************************************)
  (* View: lns *)
  let lns = ( comment | empty | record ) *

  (* View: filter *)
  let filter = (incl "/etc/apt/sources.list")
      . (incl "/etc/apt/sources.list.d/*")
      . Util.stdexcl

  let xfm = transform lns filter

(* Local Variables: *)
(* mode: caml *)
(* End: *)
`)

func assetsLensesAptsourcesAugBytes() ([]byte, error) {
	return _assetsLensesAptsourcesAug, nil
}

func assetsLensesAptsourcesAug() (*asset, error) {
	bytes, err := assetsLensesAptsourcesAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/aptsources.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesBuildAug = []byte(`(*
Module: Build
   Generic functions to build lenses

Author: Raphael Pinson <raphink@gmail.com>

About: License
  This file is licensed under the LGPL v2+, like the rest of Augeas.

About: Reference
  This file provides generic functions to build Augeas lenses
*)


module Build =

let eol = Util.eol

(************************************************************************
 * Group:               GENERIC CONSTRUCTIONS
 ************************************************************************)

(************************************************************************
 * View: brackets
 *   Put a lens inside brackets
 *
 *   Parameters:
 *     l:lens   - the left bracket lens
 *     r: lens  - the right bracket lens
 *     lns:lens - the lens to put inside brackets
 ************************************************************************)
let brackets (l:lens) (r:lens) (lns:lens) = l . lns . r


(************************************************************************
 * Group:             LIST CONSTRUCTIONS
 ************************************************************************)

(************************************************************************
 * View: list
 *   Build a list of identical lenses separated with a given separator
 *   (at least 2 elements)
 *
 *   Parameters:
 *     lns:lens - the lens to repeat in the list
 *     sep:lens - the separator lens, which can be taken from the <Sep> module
 ************************************************************************)
let list (lns:lens) (sep:lens) = lns . ( sep . lns )+


(************************************************************************
 * View: opt_list
 *   Same as <list>, but there might be only one element in the list
 *
 *   Parameters:
 *     lns:lens - the lens to repeat in the list
 *     sep:lens - the separator lens, which can be taken from the <Sep> module
 ************************************************************************)
let opt_list (lns:lens) (sep:lens) = lns . ( sep . lns )*


(************************************************************************
 * Group:                   LABEL OPERATIONS
 ************************************************************************)

(************************************************************************
 * View: xchg
 *   Replace a pattern with a different label in the tree,
 *   thus emulating a key but allowing to replace the keyword
 *   with a different value than matched
 *
 *   Parameters:
 *     m:regexp - the pattern to match
 *     d:string - the default value when a node in created
 *     l:string - the label to apply for such nodes
 ************************************************************************)
let xchg (m:regexp) (d:string) (l:string) = del m d . label l

(************************************************************************
 * View: xchgs
 *   Same as <xchg>, but the pattern is the default string
 *
 *   Parameters:
 *     m:string - the string to replace, also used as default
 *     l:string - the label to apply for such nodes
 ************************************************************************)
let xchgs (m:string) (l:string) = xchg m m l


(************************************************************************
 * Group:                   SUBNODE CONSTRUCTIONS
 ************************************************************************)

(************************************************************************
 * View: key_value_line
 *   A subnode with a keyword, a separator and a storing lens,
 *   and an end of line
 *
 *   Parameters:
 *     kw:regexp - the pattern to match as key
 *     sep:lens  - the separator lens, which can be taken from the <Sep> module
 *     sto:lens  - the storing lens
 ************************************************************************)
let key_value_line (kw:regexp) (sep:lens) (sto:lens) =
                                   [ key kw . sep . sto . eol ]

(************************************************************************
 * View: key_value_line_comment
 *   Same as <key_value_line>, but allows to have a comment in the end of a line
 *   and an end of line
 *
 *   Parameters:
 *     kw:regexp    - the pattern to match as key
 *     sep:lens     - the separator lens, which can be taken from the <Sep> module
 *     sto:lens     - the storing lens
 *     comment:lens - the comment lens, which can be taken from <Util>
 ************************************************************************)
let key_value_line_comment (kw:regexp) (sep:lens) (sto:lens) (comment:lens) =
                                   [ key kw . sep . sto . (eol|comment) ]

(************************************************************************
 * View: key_value
 *   Same as <key_value_line>, but does not end with an end of line
 *
 *   Parameters:
 *     kw:regexp - the pattern to match as key
 *     sep:lens  - the separator lens, which can be taken from the <Sep> module
 *     sto:lens  - the storing lens
 ************************************************************************)
let key_value (kw: regexp) (sep:lens) (sto:lens) =
                                   [ key kw . sep . sto ]

(************************************************************************
 * View: key_ws_value
 *
 *   Store a key/value pair where key and value are separated by whitespace
 *   and the value goes to the end of the line. Leading and trailing
 *   whitespace is stripped from the value. The end of line is consumed by
 *   this lens
 *
 *   Parameters:
 *     kw:regexp - the pattern to match as key
 ************************************************************************)
let key_ws_value (kw:regexp) =
  key_value_line kw Util.del_ws_spc (store Rx.space_in)

(************************************************************************
 * View: flag
 *   A simple flag subnode, consisting of a single key
 *
 *   Parameters:
 *     kw:regexp - the pattern to match as key
 ************************************************************************)
let flag (kw:regexp) = [ key kw ]

(************************************************************************
 * View: flag_line
 *   A simple flag line, consisting of a single key
 *
 *   Parameters:
 *     kw:regexp - the pattern to match as key
 ************************************************************************)
let flag_line (kw:regexp) = [ key kw . eol ]


(************************************************************************
 * Group:                   BLOCK CONSTRUCTIONS
 ************************************************************************)

(************************************************************************
 * View: block_generic
 *   A block enclosed in brackets
 *
 *   Parameters:
 *     entry:lens                - the entry to be stored inside the block.
 *                                 This entry should include <Util.empty>
 *                                 or its equivalent if necessary.
 *     entry_noindent:lens       - the entry to be stored inside the block,
 *                                 without indentation.
 *                                 This entry should not include <Util.empty>
 *     entry_noeol:lens          - the entry to be stored inside the block,
 *                                 without eol.
 *                                 This entry should not include <Util.empty>
 *     entry_noindent_noeol:lens - the entry to be stored inside the block,
 *                                 without indentation or eol.
 *                                 This entry should not include <Util.empty>
 *     comment:lens              - the comment lens used in the block
 *     comment_noindent:lens     - the comment lens used in the block,
 *                                 without indentation.
 *     ldelim_re:regexp          - regexp for the left delimiter
 *     rdelim_re:regexp          - regexp for the right delimiter
 *     ldelim_default:string     - default value for the left delimiter
 *     rdelim_default:string     - default value for the right delimiter
 ************************************************************************)
let block_generic
     (entry:lens) (entry_noindent:lens)
     (entry_noeol:lens) (entry_noindent_noeol:lens)
     (comment:lens) (comment_noindent:lens)
     (ldelim_re:regexp) (rdelim_re:regexp)
     (ldelim_default:string) (rdelim_default:string) =
     let block_single = entry_noindent_noeol | comment_noindent
  in let block_start  = entry_noindent | comment_noindent
  in let block_middle = (entry | comment)*
  in let block_end    = entry_noeol | comment
  in del ldelim_re ldelim_default
     . ( ( block_start . block_middle . block_end )
       | block_single )
     . del rdelim_re rdelim_default

(************************************************************************
 * View: block_setdefault
 *   A block enclosed in brackets
 *
 *   Parameters:
 *     entry:lens - the entry to be stored inside the block.
 *                  This entry should not include <Util.empty>,
 *                  <Util.comment> or <Util.comment_noindent>,
 *                  should not be indented or finish with an eol.
 *     ldelim_re:regexp      - regexp for the left delimiter
 *     rdelim_re:regexp      - regexp for the left delimiter
 *     ldelim_default:string - default value for the left delimiter
 *     rdelim_default:string - default value for the right delimiter
 ************************************************************************)
let block_setdelim (entry:lens)
                     (ldelim_re:regexp)
                     (rdelim_re:regexp)
                     (ldelim_default:string)
                     (rdelim_default:string) =
    block_generic (Util.empty | Util.indent . entry . eol)
                  (entry . eol) (Util.indent . entry) entry
                  Util.comment Util.comment_noindent
                  ldelim_re rdelim_re
                  ldelim_default rdelim_default

(* Variable: block_ldelim_re *)
let block_ldelim_re = /[ \t\n]+\{[ \t\n]*/

(* Variable: block_rdelim_re *)
let block_rdelim_re = /[ \t\n]*\}/

(* Variable: block_ldelim_default *)
let block_ldelim_default = " {\n"

(* Variable: block_rdelim_default *)
let block_rdelim_default = "}"

(************************************************************************
 * View: block
 *   A block enclosed in brackets
 *
 *   Parameters:
 *     entry:lens - the entry to be stored inside the block.
 *                  This entry should not include <Util.empty>,
 *                  <Util.comment> or <Util.comment_noindent>,
 *                  should not be indented or finish with an eol.
 ************************************************************************)
let block (entry:lens) = block_setdelim entry
                         block_ldelim_re block_rdelim_re
                         block_ldelim_default block_rdelim_default

(* Variable: block_ldelim_newlines_re *)
let block_ldelim_newlines_re = /[ \t\n]*\{([ \t\n]*\n)?/

(* Variable: block_rdelim_newlines_re *)
let block_rdelim_newlines_re = /[ \t]*\}/

(* Variable: block_ldelim_newlines_default *)
let block_ldelim_newlines_default = "\n{\n"

(* Variable: block_rdelim_newlines_default *)
let block_rdelim_newlines_default = "}"

(************************************************************************
 * View: block_newline
 *   A block enclosed in brackets, with newlines forced
 *   and indentation defaulting to a tab.
 *
 *   Parameters:
 *     entry:lens - the entry to be stored inside the block.
 *                  This entry should not include <Util.empty>,
 *                  <Util.comment> or <Util.comment_noindent>,
 *                  should be indented and finish with an eol.
 ************************************************************************)
let block_newlines (entry:lens) (comment:lens) =
   del block_ldelim_newlines_re block_ldelim_newlines_default
 . ((entry | comment) . (Util.empty | entry | comment)*)?
 . del block_rdelim_newlines_re block_rdelim_newlines_default

(************************************************************************
 * View: block_newlines_spc
 *   A block enclosed in brackets, with newlines forced
 *   and indentation defaulting to a tab. The opening brace
 *   must be preceded by whitespace
 *
 *   Parameters:
 *     entry:lens - the entry to be stored inside the block.
 *                  This entry should not include <Util.empty>,
 *                  <Util.comment> or <Util.comment_noindent>,
 *                  should be indented and finish with an eol.
 ************************************************************************)
let block_newlines_spc (entry:lens) (comment:lens) =
   del (/[ \t\n]/ . block_ldelim_newlines_re) block_ldelim_newlines_default
 . ((entry | comment) . (Util.empty | entry | comment)*)?
 . del block_rdelim_newlines_re block_rdelim_newlines_default

(************************************************************************
 * View: named_block
 *   A named <block> enclosed in brackets
 *
 *   Parameters:
 *     kw:regexp  - the regexp for the block name
 *     entry:lens - the entry to be stored inside the block
 *                   this entry should not include <Util.empty>
 ************************************************************************)
let named_block (kw:regexp) (entry:lens) = [ key kw . block entry . eol ]


(************************************************************************
 * Group:               COMBINATORICS
 ************************************************************************)

(************************************************************************
 * View: combine_two_ord
 *   Combine two lenses, ensuring first lens is first
 *
 *   Parameters:
 *     a:lens - the first lens
 *     b:lens - the second lens
 ************************************************************************)
let combine_two_ord (a:lens) (b:lens) = a . b

(************************************************************************
 * View: combine_two
 *   Combine two lenses
 *
 *   Parameters:
 *     a:lens - the first lens
 *     b:lens - the second lens
 ************************************************************************)
let combine_two (a:lens) (b:lens) =
  combine_two_ord a b | combine_two_ord b a

(************************************************************************
 * View: combine_two_opt_ord
 *   Combine two lenses optionally, ensuring first lens is first
 *   (a, and optionally b)
 *
 *   Parameters:
 *     a:lens - the first lens
 *     b:lens - the second lens
 ************************************************************************)
let combine_two_opt_ord (a:lens) (b:lens) = a . b?

(************************************************************************
 * View: combine_two_opt
 *   Combine two lenses optionally
 *   (either a, b, or both, in any order)
 *
 *   Parameters:
 *     a:lens - the first lens
 *     b:lens - the second lens
 ************************************************************************)
let combine_two_opt (a:lens) (b:lens) =
  combine_two_opt_ord a b | combine_two_opt_ord b a

(************************************************************************
 * View: combine_three_ord
 *   Combine three lenses, ensuring first lens is first
 *   (a followed by either b, c, in any order)
 *
 *   Parameters:
 *     a:lens - the first lens
 *     b:lens - the second lens
 *     c:lens - the third lens
 ************************************************************************)
let combine_three_ord (a:lens) (b:lens) (c:lens) =
  combine_two_ord a (combine_two b c)

(************************************************************************
 * View: combine_three
 *   Combine three lenses
 *
 *   Parameters:
 *     a:lens - the first lens
 *     b:lens - the second lens
 *     c:lens - the third lens
 ************************************************************************)
let combine_three (a:lens) (b:lens) (c:lens) =
    combine_three_ord a b c
  | combine_three_ord b a c
  | combine_three_ord c b a


(************************************************************************
 * View: combine_three_opt_ord
 *   Combine three lenses optionally, ensuring first lens is first
 *   (a followed by either b, c, or any of them, in any order)
 *
 *   Parameters:
 *     a:lens - the first lens
 *     b:lens - the second lens
 *     c:lens - the third lens
 ************************************************************************)
let combine_three_opt_ord (a:lens) (b:lens) (c:lens) =
  combine_two_opt_ord a (combine_two_opt b c)

(************************************************************************
 * View: combine_three_opt
 *   Combine three lenses optionally
 *   (either a, b, c, or any of them, in any order)
 *
 *   Parameters:
 *     a:lens - the first lens
 *     b:lens - the second lens
 *     c:lens - the third lens
 ************************************************************************)
let combine_three_opt (a:lens) (b:lens) (c:lens) =
    combine_three_opt_ord a b c
  | combine_three_opt_ord b a c
  | combine_three_opt_ord c b a
`)

func assetsLensesBuildAugBytes() ([]byte, error) {
	return _assetsLensesBuildAug, nil
}

func assetsLensesBuildAug() (*asset, error) {
	bytes, err := assetsLensesBuildAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/build.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesCrypttabAug = []byte(`(*
Module: Crypttab
  Parses /etc/crypttab from the cryptsetup package.

Author: Frédéric Lespez <frederic.lespez@free.fr>

About: Reference
  This lens tries to keep as close as possible to `+"`"+`man crypttab`+"`"+` where possible.

About: License
  This file is licensed under the LGPL v2+, like the rest of Augeas.

About: Lens Usage
  Sample usage of this lens in augtool

    * Create a new entry for an encrypted block devices
      > ins 01 after /files/etc/crypttab/*[last()]
      > set /files/etc/crypttab/01/target crypt_sda2
      > set /files/etc/crypttab/01/device /dev/sda2
      > set /files/etc/crypttab/01/password /dev/random
      > set /files/etc/crypttab/01/opt swap
    * Print the entry applying to the "/dev/sda2" device
      > print /files/etc/crypttab/01
    * Remove the entry applying to the "/dev/sda2" device
      > rm /files/etc/crypttab/*[device="/dev/sda2"]

About: Configuration files
  This lens applies to /etc/crypttab. See <filter>.
*)

module Crypttab =
  autoload xfm

  (************************************************************************
   * Group:                 USEFUL PRIMITIVES
   *************************************************************************)

  (* Group: Separators *)

  (* Variable: sep_tab *)
  let sep_tab = Sep.tab

  (* Variable: comma *)
  let comma   = Sep.comma

  (* Group: Generic primitives *)

  (* Variable: eol *)
  let eol     = Util.eol

  (* Variable: comment *)
  let comment = Util.comment

  (* Variable: empty *)
  let empty   = Util.empty

  (* Variable: word *)
  let word    = Rx.word

   (* Variable: optval *)
  let optval  = /[A-Za-z0-9\/_.:-]+/

  (* Variable: target *)
  let target  = Rx.device_name

  (* Variable: fspath *)
  let fspath  = Rx.fspath

  (* Variable: uuid *)
  let uuid = /UUID=[0-9a-f-]+/

  (************************************************************************
   * Group:                       ENTRIES
   *************************************************************************)

  (************************************************************************
   * View: comma_sep_list
   *   A comma separated list of options (opt=value or opt)
   *************************************************************************)
  let comma_sep_list (l:string) =
    let value = [ label "value" . Util.del_str "=" . store optval ] in
      let lns = [ label l . store word . value? ] in
         Build.opt_list lns comma

  (************************************************************************
   * View: record
   *   A crypttab record
   *************************************************************************)

  let record = [ seq "entry" .
                   [ label "target" . store target ] . sep_tab .
                   [ label "device" . store (fspath|uuid) ] .
                   (sep_tab . [ label "password" . store fspath ] .
                    ( sep_tab . comma_sep_list "opt")? )?
                 . eol ]

  (*
   * View: lns
   *   The crypttab lens
   *)
  let lns = ( empty | comment | record ) *

  (* Variable: filter *)
  let filter = (incl "/etc/crypttab")

  let xfm = transform lns filter

(* coding: utf-8 *)
`)

func assetsLensesCrypttabAugBytes() ([]byte, error) {
	return _assetsLensesCrypttabAug, nil
}

func assetsLensesCrypttabAug() (*asset, error) {
	bytes, err := assetsLensesCrypttabAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/crypttab.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesDpkgAug = []byte(`(*
Module: Dpkg
    Parses /etc/dpkg/dpkg.cfg

Author: Robin Lee Powell <rlpowell@digitalkingdom.org>

About: License
    This file, and the attendant test_dpgk.aug, are explicitly
    placed in the public domain.

About: Description
    dpkg.cfg is a simple list of options, the same ones as the
    command line options, with or without a value.

    The tree is a list of either comments or option/value pairs by
    name. Use "set" to set an option with a value, and "clear" for a
    bare option.

About: Usage Example

(start code)
    $ augtool -n
    augtool> ls /files/etc/dpkg/dpkg.cfg
    #comment[1] = dpkg configuration file
    #comment[2] = This file can contain default options for dpkg.  All command-line
    #comment[3] = options are allowed.  Values can be specified by putting them after
    #comment[4] = the option, separated by whitespace and/or an `+"`"+`=' sign.
    #comment[5] = Do not enable debsig-verify by default; since the distribution is not using
    #comment[6] = embedded signatures, debsig-verify would reject all packages.
    no-debsig = (none)
    #comment[7] = Log status changes and actions to a file.
    log = /var/log/dpkg.log
    augtool> get /files/etc/dpkg/dpkg.cfg/no-debsig
    /files/etc/dpkg/dpkg.cfg/no-debsig (none)
    augtool> get /files/etc/dpkg/dpkg.cfg/log
    /files/etc/dpkg/dpkg.cfg/log = /var/log/dpkg.log
    augtool> clear /files/etc/dpkg/dpkg.cfg/testopt
    augtool> set /files/etc/dpkg/dpkg.cfg/testopt2 test
    augtool> save
    Saved 1 file(s)
    augtool>
    $ cat /etc/dpkg/dpkg.cfg.augnew
    # dpkg configuration file
    #
    # This file can contain default options for dpkg.  All command-line
    # options are allowed.  Values can be specified by putting them after
    # the option, separated by whitespace and/or an `+"`"+`=' sign.
    #

    # Do not enable debsig-verify by default; since the distribution is not using
    # embedded signatures, debsig-verify would reject all packages.
    no-debsig

    # Log status changes and actions to a file.
    log /var/log/dpkg.log
    testopt
    testopt2 test
(end code)

*)

module Dpkg =
  autoload xfm

  let sep_tab = Util.del_ws_tab
  let sep_spc = Util.del_ws_spc
  let eol = del /[ \t]*\n/ "\n"

  let comment = Util.comment
  let empty   = Util.empty

  let word = /[^,# \n\t]+/
  let keyword = /[^,# \n\t\/]+/

  (* View: record
      Keyword, followed by optional whitespace and value, followed
      by EOL.

      The actual file specification doesn't require EOL, but the
      likelihood of the file not having one is pretty slim, and
      this way things we add have EOL.
  *)

  let record = [ key keyword . (sep_spc . store word)? . eol ]

  (* View: lns
      Any number of empty lines, comments, and records.
  *)
  let lns = ( empty | comment | record ) *

  let xfm = transform lns (incl "/etc/dpkg/dpkg.cfg")
`)

func assetsLensesDpkgAugBytes() ([]byte, error) {
	return _assetsLensesDpkgAug, nil
}

func assetsLensesDpkgAug() (*asset, error) {
	bytes, err := assetsLensesDpkgAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/dpkg.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesInifileAug = []byte(`(*
Module: IniFile
  Generic module to create INI files lenses

Author: Raphael Pinson <raphink@gmail.com>

About: License
  This file is licensed under the LGPL v2+, like the rest of Augeas.

About: TODO
  Things to add in the future
  - Support double quotes in value

About: Lens usage
  This lens is made to provide generic primitives to construct INI File lenses.
  See <Puppet>, <PHP>, <MySQL> or <Dput> for examples of real life lenses using it.

About: Examples
  The <Test_IniFile> file contains various examples and tests.
*)

module IniFile  =


(************************************************************************
 * Group:               USEFUL PRIMITIVES
 *************************************************************************)

(* Group: Internal primitives *)

(*
Variable: eol
  End of line, inherited from <Util.eol>
*)
let eol = Util.doseol


(* Group: Separators *)



(*
Variable: sep
  Generic separator

  Parameters:
    pat:regexp - the pattern to delete
    default:string - the default string to use
*)
let sep (pat:regexp) (default:string)
                       = Sep.opt_space . del pat default

(*
Variable: sep_noindent
  Generic separator, no indentation

  Parameters:
    pat:regexp - the pattern to delete
    default:string - the default string to use
*)
let sep_noindent (pat:regexp) (default:string)
                       = del pat default

(*
Variable: sep_re
  The default regexp for a separator
*)

let sep_re             = /[=:]/

(*
Variable: sep_default
  The default separator value
*)
let sep_default        = "="


(* Group: Stores *)


(*
Variable: sto_to_eol
  Store until end of line
*)
let sto_to_eol         = Sep.opt_space . store Rx.space_in

(*
Variable: to_comment_re
  Regex until comment
*)
let to_comment_re = /[^";# \t\n][^";#\n]*[^";# \t\n]|[^";# \t\n]/

(*
Variable: sto_to_comment
  Store until comment
*)
let sto_to_comment = Sep.opt_space . store to_comment_re

(*
Variable: sto_multiline
  Store multiline values
*)
let sto_multiline = Sep.opt_space
         . store (to_comment_re
               . (/[ \t]*\n/ . Rx.space . to_comment_re)*)

(*
Variable: sto_multiline_nocomment
  Store multiline values without an end-of-line comment
*)
let sto_multiline_nocomment = Sep.opt_space
         . store (Rx.space_in . (/[ \t]*\n/ . Rx.space . Rx.space_in)*)


(* Group: Define comment and defaults *)

(*
View: comment_noindent
  Map comments into "#comment" nodes,
  no indentation allowed

  Parameters:
    pat:regexp - pattern to delete before commented data
    default:string - default pattern before commented data

  Sample Usage:
  (start code)
    let comment  = IniFile.comment_noindent "#" "#"
    let comment  = IniFile.comment_noindent IniFile.comment_re IniFile.comment_default
  (end code)
*)
let comment_noindent (pat:regexp) (default:string) =
  Util.comment_generic_seteol (pat . Rx.opt_space) default eol

(*
View: comment
  Map comments into "#comment" nodes

  Parameters:
    pat:regexp - pattern to delete before commented data
    default:string - default pattern before commented data

  Sample Usage:
  (start code)
    let comment  = IniFile.comment "#" "#"
    let comment  = IniFile.comment IniFile.comment_re IniFile.comment_default
  (end code)
*)
let comment (pat:regexp) (default:string) =
  Util.comment_generic_seteol (Rx.opt_space . pat . Rx.opt_space) default eol

(*
Variable: comment_re
  Default regexp for <comment> pattern
*)

let comment_re         = /[;#]/

(*
Variable: comment_default
  Default value for <comment> pattern
*)
let comment_default    = ";"

(*
View: empty_generic
  Empty line, including empty comments

  Parameters:
    indent:regexp     - the indentation regexp
    comment_re:regexp - the comment separator regexp
*)
let empty_generic (indent:regexp) (comment_re:regexp) =
  Util.empty_generic_dos (indent . comment_re? . Rx.opt_space)

(*
View: empty
  Empty line
*)
let empty = empty_generic Rx.opt_space comment_re

(*
View: empty_noindent
  Empty line, without indentation
*)
let empty_noindent = empty_generic "" comment_re


(************************************************************************
 * Group:                     ENTRY
 *************************************************************************)

(* Group: entry includes comments *)

(*
View: entry_generic_nocomment
  A very generic INI File entry, not including comments
  It allows to set the key lens (to set indentation
  or subnodes linked to the key) as well as the comment
  separator regexp, used to tune the store regexps.

  Parameters:
    kw:lens           - lens to match the key, including optional indentation
    sep:lens          - lens to use as key/value separator
    comment_re:regexp - comment separator regexp
    comment:lens      - lens to use as comment

  Sample Usage:
     > let entry = IniFile.entry_generic (key "setting") sep IniFile.comment_re comment
*)
let entry_generic_nocomment (kw:lens) (sep:lens)
                            (comment_re:regexp) (comment:lens) =
     let bare_re_noquot = (/[^" \t\r\n]/ - comment_re)
  in let bare_re = (/[^\r\n]/ - comment_re)+
  in let no_quot = /[^"\r\n]*/
  in let bare = Quote.do_dquote_opt_nil (store (bare_re_noquot . (bare_re* . bare_re_noquot)?))
  in let quoted = Quote.do_dquote (store (no_quot . comment_re+ . no_quot))
  in [ kw . sep . (Sep.opt_space . bare)? . (comment|eol) ]
   | [ kw . sep . Sep.opt_space . quoted . (comment|eol) ]

(*
View: entry_generic
  A very generic INI File entry
  It allows to set the key lens (to set indentation
  or subnodes linked to the key) as well as the comment
  separator regexp, used to tune the store regexps.

  Parameters:
    kw:lens           - lens to match the key, including optional indentation
    sep:lens          - lens to use as key/value separator
    comment_re:regexp - comment separator regexp
    comment:lens      - lens to use as comment

  Sample Usage:
     > let entry = IniFile.entry_generic (key "setting") sep IniFile.comment_re comment
*)
let entry_generic (kw:lens) (sep:lens) (comment_re:regexp) (comment:lens) =
  entry_generic_nocomment kw sep comment_re comment | comment

(*
View: entry
  Generic INI File entry

  Parameters:
    kw:regexp    - keyword regexp for the label
    sep:lens     - lens to use as key/value separator
    comment:lens - lens to use as comment

  Sample Usage:
     > let entry = IniFile.entry setting sep comment
*)
let entry (kw:regexp) (sep:lens) (comment:lens) =
     entry_generic (key kw) sep comment_re comment

(*
View: indented_entry
  Generic INI File entry that might be indented with an arbitrary
  amount of whitespace

  Parameters:
    kw:regexp    - keyword regexp for the label
    sep:lens     - lens to use as key/value separator
    comment:lens - lens to use as comment

  Sample Usage:
     > let entry = IniFile.indented_entry setting sep comment
*)
let indented_entry (kw:regexp) (sep:lens) (comment:lens) =
     entry_generic (Util.indent . key kw) sep comment_re comment

(*
View: entry_multiline_generic
  A very generic multiline INI File entry
  It allows to set the key lens (to set indentation
  or subnodes linked to the key) as well as the comment
  separator regexp, used to tune the store regexps.

  Parameters:
    kw:lens           - lens to match the key, including optional indentation
    sep:lens          - lens to use as key/value separator
    comment_re:regexp - comment separator regexp
    comment:lens      - lens to use as comment
    eol:lens          - lens for end of line

  Sample Usage:
     > let entry = IniFile.entry_generic (key "setting") sep IniFile.comment_re comment comment_or_eol
*)
let entry_multiline_generic (kw:lens) (sep:lens) (comment_re:regexp)
                            (comment:lens) (eol:lens) =
     let newline = /\r?\n[ \t]+/
  in let bare =
          let word_re_noquot = (/[^" \t\r\n]/ - comment_re)+
       in let word_re = (/[^\r\n]/ - comment_re)+
       in let base_re = (word_re_noquot . (word_re* . word_re_noquot)?)
       in let sto_re = base_re . (newline . base_re)*
                     | (newline . base_re)+
       in Quote.do_dquote_opt_nil (store sto_re)
  in let quoted =
          let no_quot = /[^"\r\n]*/
       in let base_re = (no_quot . comment_re+ . no_quot)
       in let sto_re = base_re . (newline . base_re)*
                     | (newline . base_re)+
       in Quote.do_dquote (store sto_re)
  in [ kw . sep . (Sep.opt_space . bare)? . eol ]
   | [ kw . sep . Sep.opt_space . quoted . eol ]
   | comment
  

(*
View: entry_multiline
  Generic multiline INI File entry

  Parameters:
    kw:regexp    - keyword regexp for the label
    sep:lens     - lens to use as key/value separator
    comment:lens - lens to use as comment
*)
let entry_multiline (kw:regexp) (sep:lens) (comment:lens) =
  entry_multiline_generic (key kw) sep comment_re comment (comment|eol)

(*
View: entry_multiline_nocomment
  Generic multiline INI File entry without an end-of-line comment

  Parameters:
    kw:regexp    - keyword regexp for the label
    sep:lens     - lens to use as key/value separator
    comment:lens - lens to use as comment
*)
let entry_multiline_nocomment (kw:regexp) (sep:lens) (comment:lens) =
  entry_multiline_generic (key kw) sep comment_re comment eol

(*
View: entry_list
  Generic INI File list entry

  Parameters:
    kw:regexp     - keyword regexp for the label
    sep:lens      - lens to use as key/value separator
    sto:regexp    - store regexp for the values
    list_sep:lens - lens to use as list separator
    comment:lens  - lens to use as comment
*)
let entry_list (kw:regexp) (sep:lens) (sto:regexp) (list_sep:lens) (comment:lens) =
  let list = counter "elem"
      . Build.opt_list [ seq "elem" . store sto ] list_sep
  in Build.key_value_line_comment kw sep (Sep.opt_space . list) comment

(*
View: entry_list_nocomment
  Generic INI File list entry without an end-of-line comment

  Parameters:
    kw:regexp     - keyword regexp for the label
    sep:lens      - lens to use as key/value separator
    sto:regexp    - store regexp for the values
    list_sep:lens - lens to use as list separator
*)
let entry_list_nocomment (kw:regexp) (sep:lens) (sto:regexp) (list_sep:lens) =
  let list = counter "elem"
      . Build.opt_list [ seq "elem" . store sto ] list_sep
  in Build.key_value_line kw sep (Sep.opt_space . list)

(*
Variable: entry_re
  Default regexp for <entry> keyword
*)
let entry_re           = ( /[A-Za-z][A-Za-z0-9._-]*/ )


(************************************************************************
 * Group:                      RECORD
 *************************************************************************)

(* Group: Title definition *)

(*
View: title
  Title for <record>. This maps the title of a record as a node in the abstract tree.

  Parameters:
    kw:regexp - keyword regexp for the label

  Sample Usage:
    > let title   = IniFile.title IniFile.record_re
*)
let title (kw:regexp)
                       = Util.del_str "[" . key kw
                         . Util.del_str "]". eol

(*
View: indented_title
  Title for <record>. This maps the title of a record as a node in the abstract tree. The title may be indented with arbitrary amounts of whitespace

  Parameters:
    kw:regexp - keyword regexp for the label

  Sample Usage:
    > let title   = IniFile.title IniFile.record_re
*)
let indented_title (kw:regexp)
                       = Util.indent . title kw

(*
View: title_label
  Title for <record>. This maps the title of a record as a value in the abstract tree.

  Parameters:
    name:string - name for the title label
    kw:regexp   - keyword regexp for the label

  Sample Usage:
    > let title   = IniFile.title_label "target" IniFile.record_label_re
*)
let title_label (name:string) (kw:regexp)
                       = label name
                         . Util.del_str "[" . store kw
                         . Util.del_str "]". eol

(*
View: indented_title_label
  Title for <record>. This maps the title of a record as a value in the abstract tree. The title may be indented with arbitrary amounts of whitespace

  Parameters:
    name:string - name for the title label
    kw:regexp   - keyword regexp for the label

  Sample Usage:
    > let title   = IniFile.title_label "target" IniFile.record_label_re
*)
let indented_title_label (name:string) (kw:regexp)
                       = Util.indent . title_label name kw


(*
Variable: record_re
  Default regexp for <title> keyword pattern
*)
let record_re          = ( /[^]\r\n\/]+/ - /#comment/ )

(*
Variable: record_label_re
  Default regexp for <title_label> keyword pattern
*)
let record_label_re    = /[^]\r\n]+/


(* Group: Record definition *)

(*
View: record_noempty
  INI File Record with no empty lines allowed.

  Parameters:
    title:lens - lens to use for title. Use either <title> or <title_label>.
    entry:lens - lens to use for entries in the record. See <entry>.
*)
let record_noempty (title:lens) (entry:lens)
                       = [ title
		       . entry* ]

(*
View: record
  Generic INI File record

  Parameters:
    title:lens - lens to use for title. Use either <title> or <title_label>.
    entry:lens - lens to use for entries in the record. See <entry>.

  Sample Usage:
    > let record  = IniFile.record title entry
*)
let record (title:lens) (entry:lens)
                       = record_noempty title ( entry | empty )


(************************************************************************
 * Group:                      GENERIC LENSES
 *************************************************************************)


(*

Group: Lens definition

View: lns_noempty
  Generic INI File lens with no empty lines

  Parameters:
    record:lens  - record lens to use. See <record_noempty>.
    comment:lens - comment lens to use. See <comment>.

  Sample Usage:
    > let lns     = IniFile.lns_noempty record comment
*)
let lns_noempty (record:lens) (comment:lens)
                       = comment* . record*

(*
View: lns
  Generic INI File lens

  Parameters:
    record:lens  - record lens to use. See <record>.
    comment:lens - comment lens to use. See <comment>.

  Sample Usage:
    > let lns     = IniFile.lns record comment
*)
let lns (record:lens) (comment:lens)
                       = lns_noempty record (comment|empty)


(************************************************************************
 * Group:                   READY-TO-USE LENSES
 *************************************************************************)

let record_anon (entry:lens) = [ label "section" . value ".anon" . ( entry | empty )+ ]

(*
View: lns_loose
  A loose, ready-to-use lens, featuring:
    - sections as values (to allow '/' in names)
    - support empty lines and comments
    - support for [#;] as comment, defaulting to ";"
    - .anon sections
    - don't allow multiline values
    - allow indented titles
    - allow indented entries
*)
let lns_loose = 
     let l_comment = comment comment_re comment_default
  in let l_sep = sep sep_re sep_default
  in let l_entry = indented_entry entry_re l_sep l_comment
  in let l_title = indented_title_label "section" (record_label_re - ".anon")
  in let l_record = record l_title l_entry
  in (record_anon l_entry)? . l_record*

(*
View: lns_loose_multiline
  A loose, ready-to-use lens, featuring:
    - sections as values (to allow '/' in names)
    - support empty lines and comments
    - support for [#;] as comment, defaulting to ";"
    - .anon sections
    - allow multiline values
*)
let lns_loose_multiline = 
     let l_comment = comment comment_re comment_default
  in let l_sep = sep sep_re sep_default
  in let l_entry = entry_multiline entry_re l_sep l_comment
  in let l_title = title_label "section" (record_label_re - ".anon")
  in let l_record = record l_title l_entry
  in (record_anon l_entry)? . l_record*

`)

func assetsLensesInifileAugBytes() ([]byte, error) {
	return _assetsLensesInifileAug, nil
}

func assetsLensesInifileAug() (*asset, error) {
	bytes, err := assetsLensesInifileAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/inifile.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesLightdmAug = []byte(`(* 
Module: Lightdm
  Lightdm module for Augeas for which parses /etc/lightdm/*.conf files which
  are standard INI file format.

Author: David Salmen <dsalmen@dsalmen.com>

About: License
   This file is licenced under the LGPL v2+, like the rest of Augeas.

About: Lens Usage
   To be documented

About: Configuration files
   This lens applies to /etc/lightdm/*.conf.  See <filter>.

About: Tests
   The tests/test_lightdm.aug file contains unit tests.
*)

module Lightdm =
  autoload xfm

(************************************************************************
 * INI File settings
 *
 * lightdm.conf only supports "# as commentary and "=" as separator
 *************************************************************************)
let comment    = IniFile.comment "#" "#"
let sep        = IniFile.sep "=" "="


(************************************************************************
 *                        ENTRY
 * lightdm.conf uses standard INI File entries
 *************************************************************************)
let entry   = IniFile.indented_entry IniFile.entry_re sep comment


(************************************************************************
 *                        RECORD
 * lightdm.conf uses standard INI File records
 *************************************************************************)
let title   = IniFile.indented_title IniFile.record_re
let record  = IniFile.record title entry


(************************************************************************
 *                        LENS & FILTER
 * lightdm.conf uses standard INI File records
 *************************************************************************)
let lns     = IniFile.lns record comment

let filter = (incl "/etc/lightdm/*.conf")

let xfm = transform lns filter
`)

func assetsLensesLightdmAugBytes() ([]byte, error) {
	return _assetsLensesLightdmAug, nil
}

func assetsLensesLightdmAug() (*asset, error) {
	bytes, err := assetsLensesLightdmAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/lightdm.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesLvmAug = []byte(`(*
Module: LVM
  Parses LVM metadata.

Author: Gabriel de Perthuis	      <g2p.code+augeas@gmail.com>

About: License
  This file is licensed under the LGPL v2+.

About: Configuration files
  This lens applies to files in /etc/lvm/backup and /etc/lvm/archive.

About: Examples
  The <Test_LVM> file contains various examples and tests.
*)

module LVM =
	autoload xfm

	(* See lvm2/libdm/libdm-config.c for tokenisation;
	 * libdm uses a blacklist but I prefer the safer whitelist approach. *)
	(* View: identifier
	 * The left hand side of a definition *)
	let identifier = /[a-zA-Z0-9_-]+/

	(* strings can contain backslash-escaped dquotes, but I don't know
	 * how to get the message across to augeas *)
	let str = [label "str". Quote.do_dquote (store /([^\"]|\\\\.)*/)]
	let int = [label "int". store Rx.relinteger]
	(* View: flat_literal
	 * A literal without structure *)
	let flat_literal = int|str

	(* allow multiline and mixed int/str, used for raids and stripes *)
	(* View: list
	 * A list containing flat literals *)
	let list = [
		  label "list" . counter "list"
		. del /\[[ \t\n]*/ "["
		.([seq "list". flat_literal . del /,[ \t\n]*/ ", "]*
				. [seq "list". flat_literal . del /[ \t\n]*/ ""])?
		. Util.del_str "]"]

	(* View: val
	 * Any value that appears on the right hand side of an assignment *)
	let val = flat_literal | list

	(* View: nondef
	 * A line that doesn't contain a statement *)
	let nondef =
		  Util.empty
		| Util.comment

	(* Build.block couldn't be reused, because of recursion and
	 * a different philosophy of whitespace handling. *)
	(* View: def
	 * An assignment, or a block containing definitions *)
	let rec def = [
		  Util.indent . key identifier . (
			   del /[ \t]*\{\n/ " {\n"
			  .[label "dict".(nondef | def)*]
			  . Util.indent . Util.del_str "}\n"
			  |Sep.space_equal . val . Util.comment_or_eol)]

	(* View: lns
	 * The main lens *)
	let lns = (nondef | def)*

	let filter =
		  incl "/etc/lvm/archive/*.vg"
		. incl "/etc/lvm/backup/*"
		. incl "/etc/lvm/lvm.conf"
		. Util.stdexcl

	let xfm = transform lns filter
`)

func assetsLensesLvmAugBytes() ([]byte, error) {
	return _assetsLensesLvmAug, nil
}

func assetsLensesLvmAug() (*asset, error) {
	bytes, err := assetsLensesLvmAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/lvm.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesNsswitchAug = []byte(`(*
Module: Nsswitch
  Parses /etc/nsswitch.conf

Author: Raphael Pinson <raphink@gmail.com>

About: Reference
  This lens tries to keep as close as possible to `+"`"+`man nsswitch.conf`+"`"+` where possible.

About: Licence
  This file is licensed under the LGPL v2+, like the rest of Augeas.

About: Lens Usage

About: Configuration files
  This lens applies to /etc/nsswitch.conf. See <filter>.
*)

module Nsswitch =
autoload xfm

(************************************************************************
 * Group:                 USEFUL PRIMITIVES
 *************************************************************************)

(* View: comment *)
let comment = Util.comment

(* View: empty *)
let empty = Util.empty

(* View: sep_colon
    The separator for database entries *)
let sep_colon = del /:[ \t]*/ ": "

(* View: database_kw
    The database specification like `+"`"+`passwd', `+"`"+`shadow', or `+"`"+`hosts' *)
let database_kw = Rx.word

(* View: service
    The service specification like `+"`"+`files', `+"`"+`db', or `+"`"+`nis' *)
let service = [ label "service" . store Rx.word ]

(* View: reaction
    The reaction on lookup result like `+"`"+`[NOTFOUND=return]'
    TODO: Use case-insensitive regexps when ticket #147 is fixed.
*)
let reaction =
  let status_kw = /[Ss][Uu][Cc][Cc][Ee][Ss][Ss]/
                | /[Nn][Oo][Tt][Ff][Oo][Uu][Nn][Dd]/
                | /[Uu][Nn][Aa][Vv][Aa][Ii][Ll]/
                | /[Tt][Rr][Yy][Aa][Gg][Aa][Ii][Nn]/
    in let action_kw = /[Rr][Ee][Tt][Uu][Rr][Nn]/
                     | /[Cc][Oo][Nn][Tt][Ii][Nn][Uu][Ee]/
                     | /[Mm][Ee][Rr][Gg][Ee]/
      in let negate = [ Util.del_str "!" . label "negate" ]
        in let reaction_entry = [ label "status" . negate?
                                . store status_kw
                                . Util.del_str "="
                                . [ label "action" . store action_kw ] ]
          in Util.del_str "["
             . [ label "reaction"
               . (Build.opt_list reaction_entry Sep.space) ]
             . Util.del_str "]"

(* View: database *)
let database = 
    [ label "database" . store database_kw
       . sep_colon
       . (Build.opt_list
            (service|reaction)
            Sep.space)
       . Util.comment_or_eol ]

(* View: lns *)
let lns = ( empty | comment | database )*

(* Variable: filter *)
let filter = (incl "/etc/nsswitch.conf")

let xfm = transform lns filter
`)

func assetsLensesNsswitchAugBytes() ([]byte, error) {
	return _assetsLensesNsswitchAug, nil
}

func assetsLensesNsswitchAug() (*asset, error) {
	bytes, err := assetsLensesNsswitchAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/nsswitch.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesPamAug = []byte(`(*
Module: Pam
  Parses /etc/pam.conf and /etc/pam.d/* service files

Author: David Lutterkort <lutter@redhat.com>

About: Reference
  This lens tries to keep as close as possible to `+"`"+`man pam.conf`+"`"+` where
  possible.

About: Licence
  This file is licensed under the LGPL v2+, like the rest of Augeas.

About: Lens Usage

About: Configuration files
  This lens autoloads /etc/pam.d/* for service specific files. See <filter>.
  It provides a lens for /etc/pam.conf, which is used in the PamConf module.
*)
module Pam =
  autoload xfm

  let eol = Util.eol
  let indent = Util.indent
  let space = del /([ \t]|\\\\\n)+/ " "

  (* For the control syntax of [key=value ..] we could split the key value *)
  (* pairs into an array and generate a subtree control/N/KEY = VALUE      *)
  (* The valid control values if the [...] syntax is not used, is          *)
  (*   required|requisite|optional|sufficient|include|substack             *)
  (* We allow more than that because this list is not case sensitive and   *)
  (* to be more lenient with typos                                         *)
  let control = /(\[[^]#\n]*\]|[a-zA-Z]+)/
  let word = /([^# \t\n\\]|\\\\.)+/
  (* Allowed types *)
  let types = /(auth|session|account|password)/i

  (* This isn't entirely right: arguments enclosed in [ .. ] can contain  *)
  (* a ']' if escaped with a '\' and can be on multiple lines ('\')       *)
  let argument = /(\[[^]#\n]+\]|[^[#\n \t\\][^#\n \t\\]*)/

  let comment = Util.comment
  let comment_or_eol = Util.comment_or_eol
  let empty   = Util.empty


  (* Not mentioned in the man page, but Debian uses the syntax             *)
  (*   @include module                                                     *)
  (* quite a bit                                                           *)
  let include = [ indent . Util.del_str "@" . key "include" .
                  space . store word . eol ]

  (* Shared with PamConf *)
  let record = [ label "optional" . del "-" "-" ]? .
               [ label "type" . store types ] .
               space .
               [ label "control" . store control] .
               space .
               [ label "module" . store word ] .
               [ space . label "argument" . store argument ]* .
               comment_or_eol

  let record_svc = [ seq "record" . indent . record ]

  let lns = ( empty | comment | include | record_svc ) *

  let filter = incl "/etc/pam.d/*"
             . excl "/etc/pam.d/allow.pamlist"
             . excl "/etc/pam.d/README"
             . Util.stdexcl

  let xfm = transform lns filter

(* Local Variables: *)
(* mode: caml       *)
(* End:             *)
`)

func assetsLensesPamAugBytes() ([]byte, error) {
	return _assetsLensesPamAug, nil
}

func assetsLensesPamAug() (*asset, error) {
	bytes, err := assetsLensesPamAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/pam.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesPamconfAug = []byte(`(*
Module: PamConf
  Parses /etc/pam.conf files

Author: Dominic Cleal <dcleal@redhat.com>

About: Reference
  This lens tries to keep as close as possible to `+"`"+`man pam.conf`+"`"+` where
  possible.

About: Licence
  This file is licensed under the LGPL v2+, like the rest of Augeas.

About: Lens Usage

About: Configuration files
  This lens applies to /etc/pam.conf. See <filter>.
*)
module PamConf =
  autoload xfm

(************************************************************************
 * Group:                 USEFUL PRIMITIVES
 *************************************************************************)

let indent  = Util.indent

let comment = Util.comment

let empty   = Util.empty

let include = Pam.include

let service = Rx.word

(************************************************************************
 * Group:                 LENSES
 *************************************************************************)

let record  = [ seq "record" . indent .
              [ label "service" . store service ] .
              Sep.space .
              Pam.record ]

let lns = ( empty | comment | include | record ) *

let filter = incl "/etc/pam.conf"

let xfm = transform lns filter

(* Local Variables: *)
(* mode: caml       *)
(* End:             *)
`)

func assetsLensesPamconfAugBytes() ([]byte, error) {
	return _assetsLensesPamconfAug, nil
}

func assetsLensesPamconfAug() (*asset, error) {
	bytes, err := assetsLensesPamconfAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/pamconf.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesPasswdAug = []byte(`(*
 Module: Passwd
 Parses /etc/passwd

 Author: Free Ekanayaka <free@64studio.com>

 About: Reference
        - man 5 passwd
        - man 3 getpwnam

 Each line in the unix passwd file represents a single user record, whose
 colon-separated attributes correspond to the members of the passwd struct

*)

module Passwd =

   autoload xfm

(************************************************************************
 * Group:                    USEFUL PRIMITIVES
 *************************************************************************)

(* Group: Comments and empty lines *)

let eol        = Util.eol
let comment    = Util.comment
let empty      = Util.empty
let dels       = Util.del_str

let word       = Rx.word
let integer    = Rx.integer

let colon      = Sep.colon

let sto_to_eol = store Rx.space_in
let sto_to_col = store /[^:\r\n]+/
(* Store an empty string if nothing matches *)
let sto_to_col_or_empty = store /[^:\r\n]*/

(************************************************************************
 * Group:                        ENTRIES
 *************************************************************************)

let username  = /[_.A-Za-z0-9][-_.A-Za-z0-9]*\$?/

(* View: password
        pw_passwd *)
let password  = [ label "password" . sto_to_col?   . colon ]

(* View: uid
        pw_uid *)
let uid       = [ label "uid"      . store integer . colon ]

(* View: gid
        pw_gid *)
let gid       = [ label "gid"      . store integer . colon ]

(* View: name
        pw_gecos; the user's full name *)
let name      = [ label "name"     . sto_to_col? . colon ]

(* View: home
        pw_dir *)
let home      = [ label "home"     . sto_to_col?   . colon ]

(* View: shell
        pw_shell *)
let shell     = [ label "shell"    . sto_to_eol? ]

(* View: entry
        struct passwd *)
let entry     = [ key username
                . colon
                . password
                . uid
                . gid
                . name
                . home
                . shell
                . eol ]

(* NIS entries *)
let niscommon =  [ label "password" . sto_to_col ]?    . colon
               . [ label "uid"      . store integer ]? . colon
               . [ label "gid"      . store integer ]? . colon
               . [ label "name"     . sto_to_col ]?    . colon
               . [ label "home"     . sto_to_col ]?    . colon
               . [ label "shell"    . sto_to_eol ]?

let nisentry =
  let overrides =
        colon
      . niscommon in
  [ dels "+@" . label "@nis" . store username . overrides . eol ]

let nisuserplus =
  let overrides =
        colon
      . niscommon in
  [ dels "+" . label "@+nisuser" . store username . overrides . eol ]

let nisuserminus =
  let overrides =
        colon
      . niscommon in
  [ dels "-" . label "@-nisuser" . store username . overrides . eol ]

let nisdefault =
  let overrides =
        colon
      . [ label "password" . sto_to_col_or_empty . colon ]
      . [ label "uid"      . store integer? . colon ]
      . [ label "gid"      . store integer? . colon ]
      . [ label "name"     . sto_to_col?    . colon ]
      . [ label "home"     . sto_to_col?    . colon ]
      . [ label "shell"    . sto_to_eol? ] in
  [ dels "+" . label "@nisdefault" . overrides? . eol ]

(************************************************************************
 *                                LENS
 *************************************************************************)

let lns        = (comment|empty|entry|nisentry|nisdefault|nisuserplus|nisuserminus) *

let filter     = incl "/etc/passwd"

let xfm        = transform lns filter
`)

func assetsLensesPasswdAugBytes() ([]byte, error) {
	return _assetsLensesPasswdAug, nil
}

func assetsLensesPasswdAug() (*asset, error) {
	bytes, err := assetsLensesPasswdAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/passwd.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesQuoteAug = []byte(`(*
Module: Quote
  Generic module providing useful primitives for quoting

Author: Raphael Pinson <raphael.pinson@camptocamp.com>

About: License
   This file is licenced under the LGPL v2+, like the rest of Augeas.

About: Lens Usage
   This is a generic module which doesn't apply to files directly.
   You can use its definitions to build lenses that require quoted values.
   It provides several levels of definitions, allowing to define more or less fine-grained quoted values:

     - the quote separators are separators that are useful to define quoted values;
     - the quoting functions are useful wrappers to easily enclose a lens in various kinds of quotes (single, double, any, optional or not);
     - the quoted values definitions are common quoted patterns. They use the quoting functions in order to provide useful shortcuts for commonly met needs. In particular, the <quote_spaces> (and similar) function force values that contain spaces to be quoted, but allow values without spaces to be unquoted.

About: Examples
   The <Test_Quote> file contains various examples and tests.
*)

module Quote =

(* Group: QUOTE SEPARATORS *)

(* Variable: dquote
     A double quote *)
let dquote = Util.del_str "\""

(* Variable: dquote_opt
     An optional double quote, default to double *)
let dquote_opt = del /"?/ "\""

(* Variable: dquote_opt_nil
     An optional double quote, default to nothing *)
let dquote_opt_nil = del /"?/ ""

(* Variable: squote
     A single quote *)
let squote = Util.del_str "'"

(* Variable: squote_opt
     An optional single quote, default to single *)
let squote_opt = del /'?/ "'"

(* Variable: squote_opt_nil
     An optional single quote, default to nothing *)
let squote_opt_nil = del /'?/ ""

(* Variable: quote
     A quote, either double or single, default to double *)
let quote = del /["']/ "\""

(* Variable: quote_opt
     An optional quote, either double or single, default to double *)
let quote_opt = del /["']?/ "\""

(* Variable: quote_opt_nil
     An optional quote, either double or single, default to nothing *)
let quote_opt_nil = del /["']?/ ""


(* Group: QUOTING FUNCTIONS *)

(*
View: do_dquote
  Enclose a lens in <dquote>s

  Parameters:
    body:lens - the lens to be enclosed
*)
let do_dquote (body:lens) =
  square dquote body dquote

(*
View: do_dquote_opt
  Enclose a lens in optional <dquote>s,
  use <dquote>s by default.

  Parameters:
    body:lens - the lens to be enclosed
*)
let do_dquote_opt (body:lens) =
  square dquote_opt body dquote_opt

(*
View: do_dquote_opt_nil
  Enclose a lens in optional <dquote>s,
  default to no quotes.

  Parameters:
    body:lens - the lens to be enclosed
*)
let do_dquote_opt_nil (body:lens) =
  square dquote_opt_nil body dquote_opt_nil

(*
View: do_squote
  Enclose a lens in <squote>s

  Parameters:
    body:lens - the lens to be enclosed
*)
let do_squote (body:lens) =
  square squote body squote

(*
View: do_squote_opt
  Enclose a lens in optional <squote>s,
  use <squote>s by default.

  Parameters:
    body:lens - the lens to be enclosed
*)
let do_squote_opt (body:lens) =
  square squote_opt body squote_opt

(*
View: do_squote_opt_nil
  Enclose a lens in optional <squote>s,
  default to no quotes.

  Parameters:
    body:lens - the lens to be enclosed
*)
let do_squote_opt_nil (body:lens) =
  square squote_opt_nil body squote_opt_nil

(*
View: do_quote
  Enclose a lens in <quote>s.

  Parameters:
    body:lens - the lens to be enclosed
*)
let do_quote (body:lens) =
  square quote body quote

(*
View: do_quote
  Enclose a lens in options <quote>s.

  Parameters:
    body:lens - the lens to be enclosed
*)
let do_quote_opt (body:lens) =
  square quote_opt body quote_opt

(*
View: do_quote
  Enclose a lens in options <quote>s,
  default to no quotes.

  Parameters:
    body:lens - the lens to be enclosed
*)
let do_quote_opt_nil (body:lens) =
  square quote_opt_nil body quote_opt_nil


(* Group: QUOTED VALUES *)

(* View: double
     A double-quoted value *)
let double =
     let body = store /[^\n]*/
  in do_dquote body

(* Variable: double_opt_re
     The regexp to store when value
     is optionally double-quoted *)
let double_opt_re = /[^\n\t "]([^\n"]*[^\n\t "])?/

(* View: double_opt
     An optionally double-quoted value
     Double quotes are not allowed in value
     Value cannot begin or end with spaces *)
let double_opt =
     let body = store double_opt_re
  in do_dquote_opt body

(* View: single
     A single-quoted value *)
let single =
     let body = store /[^\n]*/
  in do_squote body

(* Variable: single_opt_re
     The regexp to store when value
     is optionally single-quoted *)
let single_opt_re = /[^\n\t ']([^\n']*[^\n\t '])?/

(* View: single_opt
     An optionally single-quoted value
     Single quotes are not allowed in value
     Value cannot begin or end with spaces *)
let single_opt =
     let body = store single_opt_re
  in do_squote_opt body

(* View: any
     A quoted value *)
let any =
     let body = store /[^\n]*/
  in do_quote body

(* Variable: any_opt_re
     The regexp to store when value
     is optionally single- or double-quoted *)
let any_opt_re = /[^\n\t "']([^\n"']*[^\n\t "'])?/

(* View: any_opt
     An optionally quoted value
     Double or single quotes are not allowed in value
     Value cannot begin or end with spaces *)
let any_opt =
     let body = store any_opt_re
  in do_quote_opt body

(*
View: quote_spaces
  Make quotes mandatory if value contains spaces,
  and optional if value doesn't contain spaces.

Parameters:
  lns:lens - the lens to be enclosed
*)
let quote_spaces (lns:lens) =
     (* bare has no spaces, and is optionally quoted *)
     let bare = Quote.do_quote_opt (store /[^"' \t\n]+/)
     (* quoted has at least one space, and must be quoted *)
  in let quoted = Quote.do_quote (store /[^"'\n]*[ \t]+[^"'\n]*/)
  in [ lns . bare ] | [ lns . quoted ]

(*
View: dquote_spaces
  Make double quotes mandatory if value contains spaces,
  and optional if value doesn't contain spaces.

Parameters:
  lns:lens - the lens to be enclosed
*)
let dquote_spaces (lns:lens) =
     (* bare has no spaces, and is optionally quoted *)
     let bare = Quote.do_dquote_opt (store /[^" \t\n]+/)
     (* quoted has at least one space, and must be quoted *)
  in let quoted = Quote.do_dquote (store /[^"\n]*[ \t]+[^"\n]*/)
  in [ lns . bare ] | [ lns . quoted ]

(*
View: squote_spaces
  Make single quotes mandatory if value contains spaces,
  and optional if value doesn't contain spaces.

Parameters:
  lns:lens - the lens to be enclosed
*)
let squote_spaces (lns:lens) =
     (* bare has no spaces, and is optionally quoted *)
     let bare = Quote.do_squote_opt (store /[^' \t\n]+/)
     (* quoted has at least one space, and must be quoted *)
  in let quoted = Quote.do_squote (store /[^'\n]*[ \t]+[^'\n]*/)
  in [ lns . bare ] | [ lns . quoted ]
`)

func assetsLensesQuoteAugBytes() ([]byte, error) {
	return _assetsLensesQuoteAug, nil
}

func assetsLensesQuoteAug() (*asset, error) {
	bytes, err := assetsLensesQuoteAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/quote.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesRxAug = []byte(`(*
Module: Rx
   Generic regexps to build lenses

Author: Raphael Pinson <raphink@gmail.com>

About: License
  This file is licensed under the LGPL v2+, like the rest of Augeas.
*)


module Rx =

(* Group: Spaces *)
(* Variable: space
   A mandatory space or tab *)
let space     = /[ \t]+/

(* Variable: opt_space
   An optional space or tab *)
let opt_space = /[ \t]*/

(* Variable: cl
   A continued line with a backslash *)
let cl = /[ \t]*\\\\\n[ \t]*/

(* Variable: cl_or_space
   A <cl> or a <space> *)
let cl_or_space = cl | space

(* Variable: cl_or_opt_space
   A <cl> or a <opt_space> *)
let cl_or_opt_space = cl | opt_space

(* Group: General strings *)

(* Variable: space_in
   A string which does not start or end with a space *)
let space_in  = /[^ \r\t\n].*[^ \r\t\n]|[^ \t\n\r]/

(* Variable: no_spaces
   A string with no spaces *)
let no_spaces = /[^ \t\r\n]+/

(* Variable: word
   An alphanumeric string *)
let word       = /[A-Za-z0-9_.-]+/

(* Variable: integer
   One or more digits *)
let integer    = /[0-9]+/

(* Variable: relinteger
   A relative <integer> *)
let relinteger = /[-+]?[0-9]+/

(* Variable: relinteger_noplus
   A relative <integer>, without explicit plus sign *)
let relinteger_noplus = /[-]?[0-9]+/

(* Variable: decimal
   A decimal value (using ',' or '.' as a separator) *)
let decimal    = /[0-9]+([.,][0-9]+)?/

(* Variable: reldecimal
   A relative <decimal> *)
let reldecimal    = /[+-]?[0-9]+([.,][0-9]+)?/

(* Variable: byte
  A byte (0 - 255) *)
let byte = /25[0-5]?|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9]/

(* Variable: hex
   A hex value *)
let hex = /0x[0-9a-fA-F]+/

(* Variable: octal
   An octal value *)
let octal = /0[0-7]+/

(* Variable: fspath
   A filesystem path *)
let fspath    = /[^ \t\n]+/

(* Group: All but... *)
(* Variable: neg1
   Anything but a space, a comma or a comment sign *)
let neg1      = /[^,# \n\t]+/

(*
 * Group: IPs
 * Cf. http://blog.mes-stats.fr/2008/10/09/regex-ipv4-et-ipv6/ (in fr)
 *)

(* Variable: ipv4 *)
let ipv4 =
  let dot     = "." in
    byte . dot . byte . dot . byte . dot . byte

(* Variable: ipv6 *)
let ipv6 =
  /(([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})/
  | /(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})/
  | /(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})/
  | /(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})/
  | /(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})/
  | /(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})/
  | (    /([0-9A-Fa-f]{1,4}:){6}/
           . /((((25[0-5])|(1[0-9]{2})|(2[0-4][0-9])|([0-9]{1,2})))\.){3}/
           . /(((25[0-5])|(1[0-9]{2})|(2[0-4][0-9])|([0-9]{1,2})))/
    )
  | (    /([0-9A-Fa-f]{1,4}:){0,5}:/
           . /((((25[0-5])|(1[0-9]{2})|(2[0-4][0-9])|([0-9]{1,2})))\.){3}/
           . /(((25[0-5])|(1[0-9]{2})|(2[0-4][0-9])|([0-9]{1,2})))/
    )
  | (    /::([0-9A-Fa-f]{1,4}:){0,5}/
           . /((((25[0-5])|(1[0-9]{2})|(2[0-4][0-9])|([0-9]{1,2})))\.){3}/
           . /(((25[0-5])|(1[0-9]{2})|(2[0-4][0-9])|([0-9]{1,2})))/
    )
  | (    /[0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}/
           . /[0-9A-Fa-f]{1,4}/
    )
  | /(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})/
  | /(([0-9A-Fa-f]{1,4}:){1,7}:)/


(* Variable: ip
   An <ipv4> or <ipv6> *)
let ip        = ipv4 | ipv6


(* Variable: hostname
   A valid RFC 1123 hostname *)
let hostname = /(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*(
                  [A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])/

(*
 * Variable: device_name
 * A Linux device name like eth0 or i2c-0. Might still be too restrictive
 *)

let device_name = /[a-zA-Z0-9_?.+:!-]+/

(*
 * Variable: email_addr
 *    To be refined
 *)
let email_addr = /[A-Za-z0-9_+.-]+@[A-Za-z0-9_.-]+/

(*
 * Variable: iso_8601
 *    ISO 8601 date time format
 *)
let year = /[0-9]{4}/
let relyear = /[-+]?/ . year
let monthday = /W?[0-9]{2}(-?[0-9]{1,2})?/
let time =
     let sep = /[T \t]/
  in let digits = /[0-9]{2}(:?[0-9]{2}(:?[0-9]{2})?)?/
  in let precis = /[.,][0-9]+/
  in let zone = "Z" | /[-+]?[0-9]{2}(:?[0-9]{2})?/
  in sep . digits . precis? . zone?
let iso_8601 = year . ("-"? . monthday . time?)?

(* Variable: url_3986
   A valid RFC 3986 url - See Appendix B *)
let url_3986 = /(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/
`)

func assetsLensesRxAugBytes() ([]byte, error) {
	return _assetsLensesRxAug, nil
}

func assetsLensesRxAug() (*asset, error) {
	bytes, err := assetsLensesRxAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/rx.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesSepAug = []byte(`(*
Module: Sep
   Generic separators to build lenses

Author: Raphael Pinson <raphink@gmail.com>

About: License
  This file is licensed under the LGPL v2+, like the rest of Augeas.
*)


module Sep =

(* Variable: colon *)
let colon = Util.del_str ":"

(* Variable: semicolon *)
let semicolon = Util.del_str ";"

(* Variable: comma *)
let comma = Util.del_str ","

(* Variable: equal *)
let equal = Util.del_str "="

(* Variable: space_equal *)
let space_equal = Util.delim "="

(* Variable: space
   Deletes a <Rx.space> and default to a single space *)
let space = del Rx.space " "

(* Variable: tab
   Deletes a <Rx.space> and default to a tab *)
let tab   = del Rx.space "\t"

(* Variable: opt_space
   Deletes a <Rx.opt_space> and default to an empty string *)
let opt_space = del Rx.opt_space ""

(* Variable: opt_tab
   Deletes a <Rx.opt_space> and default to a tab *)
let opt_tab   = del Rx.opt_space "\t"

(* Variable: cl_or_space
   Deletes a <Rx.cl_or_space> and default to a single space *)
let cl_or_space = del Rx.cl_or_space " "

(* Variable: cl_or_opt_space
   Deletes a <Rx.cl_or_opt_space> and default to a single space *)
let cl_or_opt_space = del Rx.cl_or_opt_space " "

(* Variable: lbracket *)
let lbracket = Util.del_str "("

(* Variable: rbracket *)
let rbracket = Util.del_str ")"
`)

func assetsLensesSepAugBytes() ([]byte, error) {
	return _assetsLensesSepAug, nil
}

func assetsLensesSepAug() (*asset, error) {
	bytes, err := assetsLensesSepAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/sep.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesSudoersAug = []byte(`(*
Module: Sudoers
  Parses /etc/sudoers

Author: Raphael Pinson <raphink@gmail.com>

About: Reference
  This lens tries to keep as close as possible to `+"`"+`man sudoers`+"`"+` where possible.

For example, recursive definitions such as

     > Cmnd_Spec_List ::= Cmnd_Spec |
     >                    Cmnd_Spec ',' Cmnd_Spec_List

are replaced by

  >   let cmnd_spec_list = cmnd_spec . ( sep_com . cmnd_spec )*

since Augeas cannot deal with recursive definitions.
The definitions from `+"`"+`man sudoers`+"`"+` are put as commentaries for reference
throughout the file. More information can be found in the manual.

About: License
  This file is licensed under the LGPL v2+, like the rest of Augeas.


About: Lens Usage
  Sample usage of this lens in augtool

    * Set first Defaults to apply to the "LOCALNET" network alias
      > set /files/etc/sudoers/Defaults[1]/type "@LOCALNET"
    * List all user specifications applying explicitly to the "admin" Unix group
      > match /files/etc/sudoers/spec/user "%admin"
    * Remove the full 3rd user specification
      > rm /files/etc/sudoers/spec[3]

About: Configuration files
  This lens applies to /etc/sudoers. See <filter>.
*)



module Sudoers =
  autoload xfm

(************************************************************************
 * Group:                 USEFUL PRIMITIVES
 *************************************************************************)

(* Group: Generic primitives *)
(* Variable: eol *)
let eol       = Util.eol

(* Variable: indent *)
let indent    = Util.indent


(* Group: Separators *)

(* Variable: sep_spc *)
let sep_spc  = Sep.space

(* Variable: sep_cont *)
let sep_cont = Sep.cl_or_space

(* Variable: sep_cont_opt *)
let sep_cont_opt = Sep.cl_or_opt_space

(* Variable: sep_cont_opt_build *)
let sep_cont_opt_build (sep:string) =
   del (Rx.cl_or_opt_space . sep . Rx.cl_or_opt_space) (" " . sep . " ")

(* Variable: sep_com *)
let sep_com = sep_cont_opt_build ","

(* Variable: sep_eq *)
let sep_eq   = sep_cont_opt_build "="

(* Variable: sep_col *)
let sep_col  = sep_cont_opt_build ":"

(* Variable: sep_dquote *)
let sep_dquote   = Util.del_str "\""

(* Group: Negation expressions *)

(************************************************************************
 * View: del_negate
 *   Delete an even number of '!' signs
 *************************************************************************)
let del_negate = del /(!!)*/ ""

(************************************************************************
 * View: negate_node
 *   Negation of boolean values for <defaults>. Accept one optional '!'
 *   and produce a 'negate' node if there is one.
 *************************************************************************)
let negate_node = [ del "!" "!" . label "negate" ]

(************************************************************************
 * View: negate_or_value
 *   A <del_negate>, followed by either a negated key, or a key/value pair
 *************************************************************************)
let negate_or_value (key:lens) (value:lens) =
  [ del_negate . (negate_node . key | key . value) ]

(* Group: Stores *)

(* Variable: sto_to_com_cmnd
sto_to_com_cmnd does not begin or end with a space *)

let sto_to_com_cmnd = del_negate . negate_node? . (
      let alias = Rx.word - /(NO)?(PASSWD|EXEC|SETENV)/
     in let non_alias = /[\/a-z]([^,:#()\n\\]|\\\\[=:,\\])*[^,=:#() \t\n\\]|[^,=:#() \t\n\\]/
   in store (alias | non_alias))

(* Variable: sto_to_com

There could be a \ in the middle of a command *)
let sto_to_com      = store /([^,=:#() \t\n\\][^,=:#()\n]*[^,=:#() \t\n\\])|[^,=:#() \t\n\\]/

(* Variable: sto_to_com_host *)
let sto_to_com_host = store /[^,=:#() \t\n\\]+/


(* Variable: sto_to_com_user
Escaped spaces and NIS domains and allowed*)
let sto_to_com_user =
      let nis_re = /([A-Z]([-A-Z0-9]|(\\\\[ \t]))*+\\\\\\\\)/
   in let user_re = /[%+@a-z]([-A-Za-z0-9._+]|(\\\\[ \t])|\\\\\\\\[A-Za-z0-9])*/ - /@include(dir)?/
   in let alias_re = /[A-Z_]+/
   in store ((nis_re? . user_re) | alias_re)

(* Variable: to_com_chars *)
let to_com_chars        = /[^",=#() \t\n\\]+/ (* " relax emacs *)

(* Variable: to_com_dquot *)
let to_com_dquot        = /"[^",=#()\n\\]+"/ (* " relax emacs *)

(* Variable: sto_to_com_dquot *)
let sto_to_com_dquot    = store (to_com_chars|to_com_dquot)

(* Variable: sto_to_com_col *)
let sto_to_com_col      = store to_com_chars

(* Variable: sto_to_eq *)
let sto_to_eq  = store /[^,=:#() \t\n\\]+/

(* Variable: sto_to_spc *)
let sto_to_spc = store /[^", \t\n\\]+|"[^", \t\n\\]+"/

(* Variable: sto_to_spc_no_dquote *)
let sto_to_spc_no_dquote = store /[^",# \t\n\\]+/ (* " relax emacs *)

(* Variable: sto_integer *)
let sto_integer = store /[0-9]+/


(* Group: Comments and empty lines *)

(* View: comment
Map comments in "#comment" nodes *)
let comment =
  let sto_to_eol = store (/([^ \t\n].*[^ \t\n]|[^ \t\n])/ - /include(dir)?.*/) in
  [ label "#comment" . del /[ \t]*#[ \t]*/ "# " . sto_to_eol . eol ]

(* View: comment_eol
Requires a space before the # *)
let comment_eol = Util.comment_generic /[ \t]+#[ \t]*/ " # "

(* View: comment_or_eol
A <comment_eol> or <eol> *)
let comment_or_eol = comment_eol | (del /([ \t]+#\n|[ \t]*\n)/ "\n")

(* View: empty
Map empty lines *)
let empty   = [ del /[ \t]*#?[ \t]*\n/ "\n" ]

(* View: includedir *)
let includedir =
  [ key /(#|@)include(dir)?/ . Sep.space . store Rx.fspath . eol ]


(************************************************************************
 * Group:                                    ALIASES
 *************************************************************************)

(************************************************************************
 * View: alias_field
 *   Generic alias field to gather all Alias definitions
 *
 *   Definition:
 *     > User_Alias ::= NAME '=' User_List
 *     > Runas_Alias ::= NAME '=' Runas_List
 *     > Host_Alias ::= NAME '=' Host_List
 *     > Cmnd_Alias ::= NAME '=' Cmnd_List
 *
 *   Parameters:
 *     kw:string - the label string
 *     sto:lens  - the store lens
 *************************************************************************)
let alias_field (kw:string) (sto:lens) = [ label kw . sto ]

(* View: alias_list
     List of <alias_fields>, separated by commas *)
let alias_list  (kw:string) (sto:lens) =
  Build.opt_list (alias_field kw sto) sep_com

(************************************************************************
 * View: alias_name
 *   Name of an <alias_entry_single>
 *
 *   Definition:
 *     > NAME ::= [A-Z]([A-Z][0-9]_)*
 *************************************************************************)
let alias_name
    = [ label "name" . store /[A-Z][A-Z0-9_]*/ ]

(************************************************************************
 * View: alias_entry_single
 *   Single <alias_entry>, named using <alias_name> and listing <alias_list>
 *
 *   Definition:
 *     > Alias_Type NAME = item1, item2, ...
 *
 *   Parameters:
 *     field:string - the field name, passed to <alias_list>
 *     sto:lens     - the store lens, passed to <alias_list>
 *************************************************************************)
let alias_entry_single (field:string) (sto:lens)
    = [ label "alias" . alias_name . sep_eq . alias_list field sto ]

(************************************************************************
 * View: alias_entry
 *   Alias entry, a list of comma-separated <alias_entry_single> fields
 *
 *   Definition:
 *     > Alias_Type NAME = item1, item2, item3 : NAME = item4, item5
 *
 *   Parameters:
 *     kw:string    - the alias keyword string
 *     field:string - the field name, passed to <alias_entry_single>
 *     sto:lens     - the store lens, passed to <alias_entry_single>
 *************************************************************************)
let alias_entry (kw:string) (field:string) (sto:lens)
    = [ indent . key kw . sep_cont . alias_entry_single field sto
          . ( sep_col . alias_entry_single field sto )* . comment_or_eol ]

(* TODO: go further in user definitions *)
(* View: user_alias
     User_Alias, see <alias_field> *)
let user_alias  = alias_entry "User_Alias" "user" sto_to_com
(* View: runas_alias
     Run_Alias, see <alias_field> *)
let runas_alias = alias_entry "Runas_Alias" "runas_user" sto_to_com
(* View: host_alias
     Host_Alias, see <alias_field> *)
let host_alias  = alias_entry "Host_Alias" "host" sto_to_com
(* View: cmnd_alias
     Cmnd_Alias, see <alias_field> *)
let cmnd_alias  = alias_entry "Cmnd_Alias" "command" sto_to_com_cmnd


(************************************************************************
 * View: alias
 *   Every kind of Alias entry,
 *     see <user_alias>, <runas_alias>, <host_alias> and <cmnd_alias>
 *
 *   Definition:
 *     > Alias ::= 'User_Alias'  User_Alias (':' User_Alias)* |
 *     >           'Runas_Alias' Runas_Alias (':' Runas_Alias)* |
 *     >           'Host_Alias'  Host_Alias (':' Host_Alias)* |
 *     >           'Cmnd_Alias'  Cmnd_Alias (':' Cmnd_Alias)*
 *************************************************************************)
let alias = user_alias | runas_alias | host_alias | cmnd_alias

(************************************************************************
 * Group:                          DEFAULTS
 *************************************************************************)


(************************************************************************
 * View: default_type
 *   Type definition for <defaults>
 *
 *   Definition:
 *     > Default_Type ::= 'Defaults' |
 *     >                  'Defaults' '@' Host_List |
 *     >                  'Defaults' ':' User_List |
 *     >                  'Defaults' '!' Cmnd_List |
 *     >                  'Defaults' '>' Runas_List
 *************************************************************************)
let default_type     =
  let value = store /[@:!>][^ \t\n\\]+/ in
  [ label "type" . value ]

(************************************************************************
 * View: parameter_flag
 *   A flag parameter for <defaults>
 *
 *   Flags are implicitly boolean and can be turned off via the '!'  operator.
 *   Some integer, string and list parameters may also be used in a boolean
 *     context to disable them.
 *************************************************************************)
let parameter_flag_kw    = "always_set_home" | "authenticate" | "env_editor"
                         | "env_reset" | "fqdn" | "ignore_dot"
                         | "ignore_local_sudoers" | "insults" | "log_host"
                         | "log_year" | "long_otp_prompt" | "mail_always"
                         | "mail_badpass" | "mail_no_host" | "mail_no_perms"
                         | "mail_no_user" | "noexec" | "path_info"
                         | "passprompt_override" | "preserve_groups"
                         | "requiretty" | "root_sudo" | "rootpw" | "runaspw"
                         | "set_home" | "set_logname" | "setenv"
                         | "shell_noargs" | "stay_setuid" | "targetpw"
                         | "tty_tickets" | "visiblepw" | "closefrom_override"
                         | "closefrom_override" | "compress_io" | "fast_glob"
                         | "log_input" | "log_output" | "pwfeedback"
                         | "umask_override" | "use_pty" | "match_group_by_gid"
                         | "always_query_group_plugin"

let parameter_flag       = [ del_negate . negate_node?
                               . key parameter_flag_kw ]

(************************************************************************
 * View: parameter_integer
 *   An integer parameter for <defaults>
 *************************************************************************)
let parameter_integer_nobool_kw = "passwd_tries"

let parameter_integer_nobool    = [ key parameter_integer_nobool_kw . sep_eq
                                      . del /"?/ "" . sto_integer
                                      . del /"?/ "" ]


let parameter_integer_bool_kw   = "loglinelen" | "passwd_timeout"
                                | "timestamp_timeout" | "umask"

let parameter_integer_bool      =
  negate_or_value
    (key parameter_integer_bool_kw)
    (sep_eq . del /"?/ "" . sto_integer . del /"?/ "")

let parameter_integer           = parameter_integer_nobool
                                | parameter_integer_bool

(************************************************************************
 * View: parameter_string
 *   A string parameter for <defaults>
 *
 *   An odd number of '!' operators negate the value of the item;
 *      an even number just cancel each other out.
 *************************************************************************)
let parameter_string_nobool_kw = "badpass_message" | "editor" | "mailsub"
                               | "noexec_file" | "passprompt" | "runas_default"
                               | "syslog_badpri" | "syslog_goodpri"
                               | "timestampdir" | "timestampowner" | "secure_path"

let parameter_string_nobool    = [ key parameter_string_nobool_kw . sep_eq
                                     . sto_to_com_dquot ]

let parameter_string_bool_kw   = "exempt_group" | "lecture" | "lecture_file"
                               | "listpw" | "logfile" | "mailerflags"
                               | "mailerpath" | "mailto" | "mailfrom" 
                               | "syslog" | "verifypw"

let parameter_string_bool      =
  negate_or_value
    (key parameter_string_bool_kw)
    (sep_eq . sto_to_com_dquot)

let parameter_string           = parameter_string_nobool
                               | parameter_string_bool

(************************************************************************
 * View: parameter_lists
 *   A single list parameter for <defaults>
 *
 *   All lists can be used in a boolean context
 *   The argument may be a double-quoted, space-separated list or a single
 *      value without double-quotes.
 *   The list can be replaced, added to, deleted from, or disabled
 *      by using the =, +=, -=, and ! operators respectively.
 *   An odd number of '!' operators negate the value of the item;
 *      an even number just cancel each other out.
 *************************************************************************)
let parameter_lists_kw           = "env_check" | "env_delete" | "env_keep"
let parameter_lists_value        = [ label "var" . sto_to_spc_no_dquote ]
let parameter_lists_value_dquote = [ label "var"
                                     . del /"?/ "" . sto_to_spc_no_dquote
                                     . del /"?/ "" ]

let parameter_lists_values = parameter_lists_value_dquote
                           | ( sep_dquote . parameter_lists_value
                               . ( sep_cont . parameter_lists_value )+
                               . sep_dquote )

let parameter_lists_sep    = sep_cont_opt
                             . ( [ del "+" "+" . label "append" ]
                               | [ del "-" "-" . label "remove" ] )?
                             . del "=" "=" . sep_cont_opt

let parameter_lists        =
  negate_or_value
    (key parameter_lists_kw)
    (parameter_lists_sep . parameter_lists_values)

(************************************************************************
 * View: parameter
 *   A single parameter for <defaults>
 *
 *   Definition:
 *     > Parameter ::= Parameter '=' Value |
 *     >               Parameter '+=' Value |
 *     >               Parameter '-=' Value |
 *     >               '!'* Parameter
 *
 *     Parameters may be flags, integer values, strings, or lists.
 *
 *************************************************************************)
let parameter        = parameter_flag | parameter_integer
                     | parameter_string | parameter_lists

(************************************************************************
 * View: parameter_list
 *   A list of comma-separated <parameters> for <defaults>
 *
 *   Definition:
 *     > Parameter_List ::= Parameter |
 *     >                    Parameter ',' Parameter_List
 *************************************************************************)
let parameter_list   = parameter . ( sep_com . parameter )*

(************************************************************************
 * View: defaults
 *   A Defaults entry
 *
 *   Definition:
 *     > Default_Entry ::= Default_Type Parameter_List
 *************************************************************************)
let defaults = [ indent . key "Defaults" . default_type? . sep_cont
                   . parameter_list . comment_or_eol ]



(************************************************************************
 * Group:                     USER SPECIFICATION
 *************************************************************************)

(************************************************************************
 * View: runas_spec
 *   A runas specification for <spec>, using <alias_list> for listing
 *   users and/or groups used to run a command
 *
 *   Definition:
 *     > Runas_Spec ::= '(' Runas_List ')' |
 *     >                '(:' Runas_List ')' |
 *     >                '(' Runas_List ':' Runas_List ')'
 *************************************************************************)
let runas_spec_user       = alias_list "runas_user" sto_to_com
let runas_spec_group      = Util.del_str ":" . indent
                            . alias_list "runas_group" sto_to_com

let runas_spec_usergroup  = runas_spec_user . indent . runas_spec_group

let runas_spec = Util.del_str "("
                 . (runas_spec_user
                    | runas_spec_group
                    | runas_spec_usergroup )
                 . Util.del_str ")" . sep_cont_opt

(************************************************************************
 * View: tag_spec
 *   Tag specification for <spec>
 *
 *   Definition:
 *     > Tag_Spec ::= ('NOPASSWD:' | 'PASSWD:' | 'NOEXEC:' | 'EXEC:' |
 *     >              'SETENV:' | 'NOSETENV:')
 *************************************************************************)
let tag_spec   =
  [ label "tag" . store /(NO)?(PASSWD|EXEC|SETENV)/ . sep_col ]

(************************************************************************
 * View: cmnd_spec
 *   Command specification for <spec>,
 *     with optional <runas_spec> and any amount of <tag_specs>
 *
 *   Definition:
 *     > Cmnd_Spec ::= Runas_Spec? Tag_Spec* Cmnd
 *************************************************************************)
let cmnd_spec  =
  [ label "command" .  runas_spec? . tag_spec* . sto_to_com_cmnd ]

(************************************************************************
 * View: cmnd_spec_list
 *   A list of comma-separated <cmnd_specs>
 *
 *   Definition:
 *     > Cmnd_Spec_List ::= Cmnd_Spec |
 *     >                    Cmnd_Spec ',' Cmnd_Spec_List
 *************************************************************************)
let cmnd_spec_list = Build.opt_list cmnd_spec sep_com


(************************************************************************
 * View: spec_list
 *   Group of hosts with <cmnd_spec_list>
 *************************************************************************)
let spec_list = [ label "host_group" . alias_list "host" sto_to_com_host
                    . sep_eq . cmnd_spec_list ]

(************************************************************************
 * View: spec
 *   A user specification, listing colon-separated <spec_lists>
 *
 *   Definition:
 *     > User_Spec ::= User_List Host_List '=' Cmnd_Spec_List \
 *     >               (':' Host_List '=' Cmnd_Spec_List)*
 *************************************************************************)
let spec = [ label "spec" . indent
               . alias_list "user" sto_to_com_user . sep_cont
               . Build.opt_list spec_list sep_col
               . comment_or_eol ]


(************************************************************************
 * Group:                        LENS & FILTER
 *************************************************************************)

(* View: lns
     The sudoers lens, any amount of
       * <empty> lines
       * <comments>
       * <includedirs>
       * <aliases>
       * <defaults>
       * <specs>
*)
let lns = ( empty | comment | includedir | alias | defaults | spec  )*

(* View: filter *)
let filter = (incl "/etc/sudoers")
    . (incl "/usr/local/etc/sudoers")
    . (incl "/etc/sudoers.d/*")
    . (incl "/usr/local/etc/sudoers.d/*")
    . (incl "/opt/csw/etc/sudoers")
    . (incl "/etc/opt/csw/sudoers")
    . Util.stdexcl

let xfm = transform lns filter
`)

func assetsLensesSudoersAugBytes() ([]byte, error) {
	return _assetsLensesSudoersAug, nil
}

func assetsLensesSudoersAug() (*asset, error) {
	bytes, err := assetsLensesSudoersAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/sudoers.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesUtilAug = []byte(`(*
Module: Util
  Generic module providing useful primitives

Author: David Lutterkort

About: License
  This file is licensed under the LGPLv2+, like the rest of Augeas.
*)


module Util =


(*
Variable: del_str
  Delete a string and default to it

  Parameters:
     s:string - the string to delete and default to
*)
  let del_str (s:string) = del s s

(*
Variable: del_ws
  Delete mandatory whitespace
*)
  let del_ws = del /[ \t]+/

(*
Variable: del_ws_spc
  Delete mandatory whitespace, default to single space
*)
  let del_ws_spc = del_ws " "

(*
Variable: del_ws_tab
  Delete mandatory whitespace, default to single tab
*)
  let del_ws_tab = del_ws "\t"


(*
Variable: del_opt_ws
  Delete optional whitespace
*)
  let del_opt_ws = del /[ \t]*/


(*
Variable: eol
  Delete end of line, including optional trailing whitespace
*)
  let eol = del /[ \t]*\n/ "\n"

(*
Variable: doseol
  Delete end of line with optional carriage return,
  including optional trailing whitespace
*)
  let doseol = del /[ \t]*\r?\n/ "\n"
   

(*
Variable: indent
  Delete indentation, including leading whitespace
*)
  let indent = del /[ \t]*/ ""

(* Group: Comment
     This is a general definition of comment
     It allows indentation for comments, removes the leading and trailing spaces
     of comments and stores them in nodes, except for empty comments which are
     ignored together with empty lines
*)


(* View: comment_generic_seteol
  Map comments and set default comment sign
*)

  let comment_generic_seteol (r:regexp) (d:string) (eol:lens) =
    [ label "#comment" . del r d
        . store /([^ \t\r\n].*[^ \t\r\n]|[^ \t\r\n])/ . eol ]

(* View: comment_generic
  Map comments and set default comment sign
*)

  let comment_generic (r:regexp) (d:string) =
    comment_generic_seteol r d doseol

(* View: comment
  Map comments into "#comment" nodes
*)
  let comment = comment_generic /[ \t]*#[ \t]*/ "# "

(* View: comment_noindent
  Map comments into "#comment" nodes, without indentation
*)
  let comment_noindent = comment_generic /#[ \t]*/ "# "

(* View: comment_eol
  Map eol comments into "#comment" nodes
  Add a space before # for end of line comments
*)
  let comment_eol = comment_generic /[ \t]*#[ \t]*/ " # "

(* View: comment_or_eol
    A <comment_eol> or <eol>, with an optional empty comment *)
 let comment_or_eol = comment_eol | (del /[ \t]*(#[ \t]*)?\n/ "\n")

(* View: comment_multiline
    A C-style multiline comment *)
  let comment_multiline =
     let mline_re = (/[^ \t\r\n].*[^ \t\r\n]|[^ \t\r\n]/ - /.*\*\/.*/) in
     let mline = [ seq "mline"
                 . del /[ \t\r\n]*/ "\n"
                 . store mline_re ] in
     [ label "#mcomment" . del /[ \t]*\/\*/ "/*"
       . counter "mline"
       . mline . (eol . mline)*
       . del /[ \t\r\n]*\*\/[ \t]*\r?\n/ "\n*/\n" ]

(* View: comment_c_style
    A comment line, C-style *)
  let comment_c_style =
    comment_generic /[ \t]*\/\/[ \t]*/ "// "

(* View: comment_c_style_or_hash
    A comment line, C-style or hash *)
  let comment_c_style_or_hash =
    comment_generic /[ \t]*((\/\/)|#)[ \t]*/ "// "

(* View: empty_generic
  A generic definition of <empty>
  Map empty lines, including empty comments *)
  let empty_generic (r:regexp) =
    [ del r "" . del_str "\n" ]

(* Variable: empty_generic_re *)
  let empty_generic_re = /[ \t]*#?[ \t]*/

(* View: empty
  Map empty lines, including empty comments *)
  let empty = empty_generic empty_generic_re

(* Variable: empty_c_style_re *)
  let empty_c_style_re = /[ \t]*((\/\/)|(\/\*[ \t]*\*\/))?[ \t]*/

(* View: empty_c_style
  Map empty lines, including C-style empty comment *)
  let empty_c_style = empty_generic empty_c_style_re

(* View: empty_any
  Either <empty> or <empty_c_style> *)
  let empty_any = empty_generic (empty_generic_re | empty_c_style_re)

(* View: empty_generic_dos
  A generic definition of <empty> with dos newlines
  Map empty lines, including empty comments *)
  let empty_generic_dos (r:regexp) =
    [ del r "" . del /\r?\n/ "\n" ]

(* View: empty_dos *)
  let empty_dos =
    empty_generic_dos /[ \t]*#?[ \t]*/


(* View: Split *)
(* Split (SEP . ELT)* into an array-like tree where each match for ELT *)
(* appears in a separate subtree. The labels for the subtrees are      *)
(* consecutive numbers, starting at 0                                  *)
  let split (elt:lens) (sep:lens) =
    let sym = gensym "split" in
    counter sym . ( [ seq sym . sep . elt ] ) *

(* View: delim *)
  let delim (op:string) = del (/[ \t]*/ . op . /[ \t]*/)
                              (" " . op . " ")

(* Group: Exclusions

Variable: stdexcl
  Exclusion for files that are commonly not wanted/needed
*)
  let stdexcl = (excl "*~") .
    (excl "*.rpmnew") .
    (excl "*.rpmsave") .
    (excl "*.dpkg-old") .
    (excl "*.dpkg-new") .
    (excl "*.dpkg-bak") .
    (excl "*.dpkg-dist") .
    (excl "*.augsave") .
    (excl "*.augnew") .
    (excl "*.bak") .
    (excl "*.old") .
    (excl "#*#")
`)

func assetsLensesUtilAugBytes() ([]byte, error) {
	return _assetsLensesUtilAug, nil
}

func assetsLensesUtilAug() (*asset, error) {
	bytes, err := assetsLensesUtilAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/util.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsLensesYumAug = []byte(`(* Parsing yum's config files *)
module Yum =
  autoload xfm

(************************************************************************
 * INI File settings
 *************************************************************************)

let comment  = IniFile.comment "#" "#"
let sep      = IniFile.sep "=" "="
let empty    = Util.empty
let eol      = IniFile.eol

(************************************************************************
 *                        ENTRY
 *************************************************************************)

let list_entry (list_key:string)  =
  let list_value = store /[^# \t\r\n,][^ \t\r\n,]*[^# \t\r\n,]|[^# \t\r\n,]/ in
  let list_sep = del /([ \t]*(,[ \t]*|\r?\n[ \t]+))|[ \t]+/ "\n\t" in
  [ key list_key . sep . Sep.opt_space . list_value ]
  . (list_sep . Build.opt_list [ label list_key . list_value ] list_sep)?
  . eol

let entry_re = IniFile.entry_re - ("baseurl" | "gpgkey" | "exclude")

let entry       = IniFile.entry entry_re sep comment
                | empty

let entries =
     let list_entry_elem (k:string) = list_entry k . entry*
  in entry*
   | entry* . Build.combine_three_opt
                (list_entry_elem "baseurl")
                (list_entry_elem "gpgkey")
                (list_entry_elem "exclude")


(***********************************************************************a
 *                         TITLE
 *************************************************************************)
let title       = IniFile.title IniFile.record_re
let record      = [ title . entries ]


(************************************************************************
 *                         LENS & FILTER
 *************************************************************************)
let lns    = (empty | comment)* . record*

  let filter = (incl "/etc/yum.conf")
      . (incl "/etc/yum.repos.d/*.repo")
      . (incl "/etc/yum/yum-cron*.conf") 
      . (incl "/etc/yum/pluginconf.d/*")
      . (excl "/etc/yum/pluginconf.d/versionlock.list")
      . (incl "/etc/dnf/dnf.conf")
      . (incl "/etc/dnf/automatic.conf")
      . (incl "/etc/dnf/plugins/*.conf")
      . Util.stdexcl

  let xfm = transform lns filter

(* Local Variables: *)
(* mode: caml       *)
(* End:             *)
`)

func assetsLensesYumAugBytes() ([]byte, error) {
	return _assetsLensesYumAug, nil
}

func assetsLensesYumAug() (*asset, error) {
	bytes, err := assetsLensesYumAugBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/lenses/yum.aug", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("Asset %s can't read by error: %v", name, err)
		}
		return a.bytes, nil
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("AssetInfo %s can't read by error: %v", name, err)
		}
		return a.info, nil
	}
	return nil, fmt.Errorf("AssetInfo %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() (*asset, error){
	"assets/lenses/access.aug": assetsLensesAccessAug,
	"assets/lenses/apt_update_manager.aug": assetsLensesApt_update_managerAug,
	"assets/lenses/aptcacherngsecurity.aug": assetsLensesAptcacherngsecurityAug,
	"assets/lenses/aptconf.aug": assetsLensesAptconfAug,
	"assets/lenses/aptpreferences.aug": assetsLensesAptpreferencesAug,
	"assets/lenses/aptsources.aug": assetsLensesAptsourcesAug,
	"assets/lenses/build.aug": assetsLensesBuildAug,
	"assets/lenses/crypttab.aug": assetsLensesCrypttabAug,
	"assets/lenses/dpkg.aug": assetsLensesDpkgAug,
	"assets/lenses/inifile.aug": assetsLensesInifileAug,
	"assets/lenses/lightdm.aug": assetsLensesLightdmAug,
	"assets/lenses/lvm.aug": assetsLensesLvmAug,
	"assets/lenses/nsswitch.aug": assetsLensesNsswitchAug,
	"assets/lenses/pam.aug": assetsLensesPamAug,
	"assets/lenses/pamconf.aug": assetsLensesPamconfAug,
	"assets/lenses/passwd.aug": assetsLensesPasswdAug,
	"assets/lenses/quote.aug": assetsLensesQuoteAug,
	"assets/lenses/rx.aug": assetsLensesRxAug,
	"assets/lenses/sep.aug": assetsLensesSepAug,
	"assets/lenses/sudoers.aug": assetsLensesSudoersAug,
	"assets/lenses/util.aug": assetsLensesUtilAug,
	"assets/lenses/yum.aug": assetsLensesYumAug,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for childName := range node.Children {
		rv = append(rv, childName)
	}
	return rv, nil
}

type bintree struct {
	Func     func() (*asset, error)
	Children map[string]*bintree
}
var _bintree = &bintree{nil, map[string]*bintree{
	"assets": &bintree{nil, map[string]*bintree{
		"lenses": &bintree{nil, map[string]*bintree{
			"access.aug": &bintree{assetsLensesAccessAug, map[string]*bintree{}},
			"apt_update_manager.aug": &bintree{assetsLensesApt_update_managerAug, map[string]*bintree{}},
			"aptcacherngsecurity.aug": &bintree{assetsLensesAptcacherngsecurityAug, map[string]*bintree{}},
			"aptconf.aug": &bintree{assetsLensesAptconfAug, map[string]*bintree{}},
			"aptpreferences.aug": &bintree{assetsLensesAptpreferencesAug, map[string]*bintree{}},
			"aptsources.aug": &bintree{assetsLensesAptsourcesAug, map[string]*bintree{}},
			"build.aug": &bintree{assetsLensesBuildAug, map[string]*bintree{}},
			"crypttab.aug": &bintree{assetsLensesCrypttabAug, map[string]*bintree{}},
			"dpkg.aug": &bintree{assetsLensesDpkgAug, map[string]*bintree{}},
			"inifile.aug": &bintree{assetsLensesInifileAug, map[string]*bintree{}},
			"lightdm.aug": &bintree{assetsLensesLightdmAug, map[string]*bintree{}},
			"lvm.aug": &bintree{assetsLensesLvmAug, map[string]*bintree{}},
			"nsswitch.aug": &bintree{assetsLensesNsswitchAug, map[string]*bintree{}},
			"pam.aug": &bintree{assetsLensesPamAug, map[string]*bintree{}},
			"pamconf.aug": &bintree{assetsLensesPamconfAug, map[string]*bintree{}},
			"passwd.aug": &bintree{assetsLensesPasswdAug, map[string]*bintree{}},
			"quote.aug": &bintree{assetsLensesQuoteAug, map[string]*bintree{}},
			"rx.aug": &bintree{assetsLensesRxAug, map[string]*bintree{}},
			"sep.aug": &bintree{assetsLensesSepAug, map[string]*bintree{}},
			"sudoers.aug": &bintree{assetsLensesSudoersAug, map[string]*bintree{}},
			"util.aug": &bintree{assetsLensesUtilAug, map[string]*bintree{}},
			"yum.aug": &bintree{assetsLensesYumAug, map[string]*bintree{}},
		}},
	}},
}}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	data, err := Asset(name)
	if err != nil {
		return err
	}
	info, err := AssetInfo(name)
	if err != nil {
		return err
	}
	err = os.MkdirAll(_filePath(dir, filepath.Dir(name)), os.FileMode(0755))
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(_filePath(dir, name), data, info.Mode())
	if err != nil {
		return err
	}
	err = os.Chtimes(_filePath(dir, name), info.ModTime(), info.ModTime())
	if err != nil {
		return err
	}
	return nil
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	children, err := AssetDir(name)
	// File
	if err != nil {
		return RestoreAsset(dir, name)
	}
	// Dir
	for _, child := range children {
		err = RestoreAssets(dir, filepath.Join(name, child))
		if err != nil {
			return err
		}
	}
	return nil
}

func _filePath(dir, name string) string {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	return filepath.Join(append([]string{dir}, strings.Split(cannonicalName, "/")...)...)
}

